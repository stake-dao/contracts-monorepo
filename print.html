<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Stake DAO Fusion</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="book.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">README</a></li><li class="chapter-item expanded "><a href="src/RouterModules/index.html"><strong aria-hidden="true">1.</strong> RouterModules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="src/RouterModules/RouterIdentifierMapping.sol/library.RouterIdentifierMapping.html"><strong aria-hidden="true">1.1.</strong> RouterIdentifierMapping</a></li><li class="chapter-item expanded "><a href="src/RouterModules/RouterModuleClaim.sol/contract.RouterModuleClaim.html"><strong aria-hidden="true">1.2.</strong> RouterModuleClaim</a></li><li class="chapter-item expanded "><a href="src/RouterModules/RouterModuleDeposit.sol/contract.RouterModuleDeposit.html"><strong aria-hidden="true">1.3.</strong> RouterModuleDeposit</a></li><li class="chapter-item expanded "><a href="src/RouterModules/RouterModuleMigrationCurve.sol/contract.RouterModuleMigrationCurve.html"><strong aria-hidden="true">1.4.</strong> RouterModuleMigrationCurve</a></li><li class="chapter-item expanded "><a href="src/RouterModules/RouterModuleMigrationStakeDAOV1.sol/interface.IVault.html"><strong aria-hidden="true">1.5.</strong> IVault</a></li><li class="chapter-item expanded "><a href="src/RouterModules/RouterModuleMigrationStakeDAOV1.sol/contract.RouterModuleMigrationStakeDAOV1.html"><strong aria-hidden="true">1.6.</strong> RouterModuleMigrationStakeDAOV1</a></li><li class="chapter-item expanded "><a href="src/RouterModules/RouterModuleMigrationYearn.sol/contract.RouterModuleMigrationYearn.html"><strong aria-hidden="true">1.7.</strong> RouterModuleMigrationYearn</a></li><li class="chapter-item expanded "><a href="src/RouterModules/RouterModuleMigrationYearn.sol/interface.IYearnVault.html"><strong aria-hidden="true">1.8.</strong> IYearnVault</a></li><li class="chapter-item expanded "><a href="src/RouterModules/RouterModuleWithdraw.sol/contract.RouterModuleWithdraw.html"><strong aria-hidden="true">1.9.</strong> RouterModuleWithdraw</a></li></ol></li><li class="chapter-item expanded "><a href="src/integrations/index.html"><strong aria-hidden="true">2.</strong> integrations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="src/integrations/curve/index.html"><strong aria-hidden="true">2.1.</strong> curve</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="src/integrations/curve/ConvexSidecar.sol/contract.ConvexSidecar.html"><strong aria-hidden="true">2.1.1.</strong> ConvexSidecar</a></li><li class="chapter-item expanded "><a href="src/integrations/curve/ConvexSidecarFactory.sol/contract.ConvexSidecarFactory.html"><strong aria-hidden="true">2.1.2.</strong> ConvexSidecarFactory</a></li><li class="chapter-item expanded "><a href="src/integrations/curve/CurveAllocator.sol/contract.CurveAllocator.html"><strong aria-hidden="true">2.1.3.</strong> CurveAllocator</a></li><li class="chapter-item expanded "><a href="src/integrations/curve/CurveFactory.sol/contract.CurveFactory.html"><strong aria-hidden="true">2.1.4.</strong> CurveFactory</a></li><li class="chapter-item expanded "><a href="src/integrations/curve/CurveStrategy.sol/contract.CurveStrategy.html"><strong aria-hidden="true">2.1.5.</strong> CurveStrategy</a></li></ol></li><li class="chapter-item expanded "><a href="src/integrations/yieldnest/index.html"><strong aria-hidden="true">2.2.</strong> yieldnest</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="src/integrations/yieldnest/YieldnestAutocompoundedVault.sol/contract.YieldnestAutocompoundedVault.html"><strong aria-hidden="true">2.2.1.</strong> YieldnestAutocompoundedVault</a></li><li class="chapter-item expanded "><a href="src/integrations/yieldnest/YieldnestOFT.sol/contract.YieldnestOFT.html"><strong aria-hidden="true">2.2.2.</strong> YieldnestOFT</a></li><li class="chapter-item expanded "><a href="src/integrations/yieldnest/YieldnestOFTAdapter.sol/contract.YieldnestOFTAdapter.html"><strong aria-hidden="true">2.2.3.</strong> YieldnestOFTAdapter</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="src/interfaces/index.html"><strong aria-hidden="true">3.</strong> interfaces</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="src/interfaces/IAccountant.sol/interface.IAccountant.html"><strong aria-hidden="true">3.1.</strong> IAccountant</a></li><li class="chapter-item expanded "><a href="src/interfaces/IAllocator.sol/interface.IAllocator.html"><strong aria-hidden="true">3.2.</strong> IAllocator</a></li><li class="chapter-item expanded "><a href="src/interfaces/IBalanceProvider.sol/interface.IBalanceProvider.html"><strong aria-hidden="true">3.3.</strong> IBalanceProvider</a></li><li class="chapter-item expanded "><a href="src/interfaces/IProtocolContext.sol/interface.IProtocolContext.html"><strong aria-hidden="true">3.4.</strong> IProtocolContext</a></li><li class="chapter-item expanded "><a href="src/interfaces/IProtocolController.sol/interface.IProtocolController.html"><strong aria-hidden="true">3.5.</strong> IProtocolController</a></li><li class="chapter-item expanded "><a href="src/interfaces/IRewardReceiver.sol/interface.IRewardReceiver.html"><strong aria-hidden="true">3.6.</strong> IRewardReceiver</a></li><li class="chapter-item expanded "><a href="src/interfaces/IRewardVault.sol/interface.IRewardVault.html"><strong aria-hidden="true">3.7.</strong> IRewardVault</a></li><li class="chapter-item expanded "><a href="src/interfaces/IRouter.sol/interface.IRouter.html"><strong aria-hidden="true">3.8.</strong> IRouter</a></li><li class="chapter-item expanded "><a href="src/interfaces/IRouterModule.sol/interface.IRouterModule.html"><strong aria-hidden="true">3.9.</strong> IRouterModule</a></li><li class="chapter-item expanded "><a href="src/interfaces/ISidecar.sol/interface.ISidecar.html"><strong aria-hidden="true">3.10.</strong> ISidecar</a></li><li class="chapter-item expanded "><a href="src/interfaces/ISidecarFactory.sol/interface.ISidecarFactory.html"><strong aria-hidden="true">3.11.</strong> ISidecarFactory</a></li><li class="chapter-item expanded "><a href="src/interfaces/IStrategy.sol/interface.IStrategy.html"><strong aria-hidden="true">3.12.</strong> IStrategy</a></li></ol></li><li class="chapter-item expanded "><a href="src/libraries/index.html"><strong aria-hidden="true">4.</strong> libraries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="src/libraries/ImmutableArgsParser.sol/library.ImmutableArgsParser.html"><strong aria-hidden="true">4.1.</strong> ImmutableArgsParser</a></li><li class="chapter-item expanded "><a href="src/libraries/LayerZeroEID.sol/library.LayerZeroEID.html"><strong aria-hidden="true">4.2.</strong> LayerZeroEID</a></li></ol></li><li class="chapter-item expanded "><a href="src/merkl/index.html"><strong aria-hidden="true">5.</strong> merkl</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="src/merkl/UniversalBoostRegistry.sol/contract.UniversalBoostRegistry.html"><strong aria-hidden="true">5.1.</strong> UniversalBoostRegistry</a></li></ol></li><li class="chapter-item expanded "><a href="src/Accountant.sol/contract.Accountant.html"><strong aria-hidden="true">6.</strong> Accountant</a></li><li class="chapter-item expanded "><a href="src/Allocator.sol/contract.Allocator.html"><strong aria-hidden="true">7.</strong> Allocator</a></li><li class="chapter-item expanded "><a href="src/AutocompoundedVault.sol/contract.AutocompoundedVault.html"><strong aria-hidden="true">8.</strong> AutocompoundedVault</a></li><li class="chapter-item expanded "><a href="src/Factory.sol/abstract.Factory.html"><strong aria-hidden="true">9.</strong> Factory</a></li><li class="chapter-item expanded "><a href="src/ProtocolContext.sol/contract.ProtocolContext.html"><strong aria-hidden="true">10.</strong> ProtocolContext</a></li><li class="chapter-item expanded "><a href="src/ProtocolController.sol/contract.ProtocolController.html"><strong aria-hidden="true">11.</strong> ProtocolController</a></li><li class="chapter-item expanded "><a href="src/RewardReceiver.sol/contract.RewardReceiver.html"><strong aria-hidden="true">12.</strong> RewardReceiver</a></li><li class="chapter-item expanded "><a href="src/RewardVault.sol/contract.RewardVault.html"><strong aria-hidden="true">13.</strong> RewardVault</a></li><li class="chapter-item expanded "><a href="src/Router.sol/contract.Router.html"><strong aria-hidden="true">14.</strong> Router</a></li><li class="chapter-item expanded "><a href="src/Sidecar.sol/abstract.Sidecar.html"><strong aria-hidden="true">15.</strong> Sidecar</a></li><li class="chapter-item expanded "><a href="src/SidecarFactory.sol/abstract.SidecarFactory.html"><strong aria-hidden="true">16.</strong> SidecarFactory</a></li><li class="chapter-item expanded "><a href="src/Strategy.sol/abstract.Strategy.html"><strong aria-hidden="true">17.</strong> Strategy</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Stake DAO Fusion</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/stake-dao/contracts-monorepo" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>This repository follows the <strong>Branching Tree Technique (BTT)</strong> for structuring test specifications. This methodology enhances clarity and coverage by modeling test cases as branching decision trees.</p>
<h3 id="branching-tree-technique"><a class="header" href="#branching-tree-technique">Branching Tree Technique</a></h3>
<p>The test specifications are structured using BTT, as outlined in the following references:</p>
<ul>
<li><a href="https://x.com/PaulRBerg/status/1682346315806539776">Paul R. Berg's Introduction to BTT</a></li>
<li><a href="https://shubhchain.hashnode.dev/smart-contract-testing-made-easy">BTT Overview by Shubhchain</a></li>
<li><a href="https://github.com/PaulRBerg/btt-examples">Example BTT Implementations</a></li>
</ul>
<h3 id="generating-tests-with-bulloak"><a class="header" href="#generating-tests-with-bulloak">Generating Tests with Bulloak</a></h3>
<p>We highly recommend using <a href="https://github.com/alexfertel/bulloak">Bulloak</a> to generate test files from BTT specifications automatically.</p>
<p>To scaffold test files from your branching tree specification, run:</p>
<pre><code class="language-sh">bulloak scaffold -w &lt;file_name&gt;.tree
</code></pre>
<h3 id="ensuring-consistency-in-ci"><a class="header" href="#ensuring-consistency-in-ci">Ensuring Consistency in CI</a></h3>
<p>To pass the CI pipeline, the Solidity files in this package must align with the defined test specifications. You can verify this compliance using:</p>
<pre><code class="language-sh">bulloak check
</code></pre>
<p>This ensures that test definitions remain consistent with the implemented smart contract logic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contents"><a class="header" href="#contents">Contents</a></h1>
<ul>
<li><a href="src/RouterModules/RouterIdentifierMapping.sol/library.RouterIdentifierMapping.html">RouterIdentifierMapping</a></li>
<li><a href="src/RouterModules/RouterModuleClaim.sol/contract.RouterModuleClaim.html">RouterModuleClaim</a></li>
<li><a href="src/RouterModules/RouterModuleDeposit.sol/contract.RouterModuleDeposit.html">RouterModuleDeposit</a></li>
<li><a href="src/RouterModules/RouterModuleMigrationCurve.sol/contract.RouterModuleMigrationCurve.html">RouterModuleMigrationCurve</a></li>
<li><a href="src/RouterModules/RouterModuleMigrationStakeDAOV1.sol/interface.IVault.html">IVault</a></li>
<li><a href="src/RouterModules/RouterModuleMigrationStakeDAOV1.sol/contract.RouterModuleMigrationStakeDAOV1.html">RouterModuleMigrationStakeDAOV1</a></li>
<li><a href="src/RouterModules/RouterModuleMigrationYearn.sol/contract.RouterModuleMigrationYearn.html">RouterModuleMigrationYearn</a></li>
<li><a href="src/RouterModules/RouterModuleMigrationYearn.sol/interface.IYearnVault.html">IYearnVault</a></li>
<li><a href="src/RouterModules/RouterModuleWithdraw.sol/contract.RouterModuleWithdraw.html">RouterModuleWithdraw</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="routeridentifiermapping"><a class="header" href="#routeridentifiermapping">RouterIdentifierMapping</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/RouterModules/RouterIdentifierMapping.sol">Git Source</a></p>
<h2 id="state-variables"><a class="header" href="#state-variables">State Variables</a></h2>
<h3 id="deposit"><a class="header" href="#deposit">DEPOSIT</a></h3>
<pre><code class="language-solidity">uint8 internal constant DEPOSIT = 0x00;
</code></pre>
<h3 id="withdraw"><a class="header" href="#withdraw">WITHDRAW</a></h3>
<pre><code class="language-solidity">uint8 internal constant WITHDRAW = 0x01;
</code></pre>
<h3 id="claim"><a class="header" href="#claim">CLAIM</a></h3>
<pre><code class="language-solidity">uint8 internal constant CLAIM = 0x02;
</code></pre>
<h3 id="migration_stake_dao_v1"><a class="header" href="#migration_stake_dao_v1">MIGRATION_STAKE_DAO_V1</a></h3>
<pre><code class="language-solidity">uint8 internal constant MIGRATION_STAKE_DAO_V1 = 0x03;
</code></pre>
<h3 id="migration_curve"><a class="header" href="#migration_curve">MIGRATION_CURVE</a></h3>
<pre><code class="language-solidity">uint8 internal constant MIGRATION_CURVE = 0x04;
</code></pre>
<h3 id="migration_yearn"><a class="header" href="#migration_yearn">MIGRATION_YEARN</a></h3>
<pre><code class="language-solidity">uint8 internal constant MIGRATION_YEARN = 0x05;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="routermoduleclaim"><a class="header" href="#routermoduleclaim">RouterModuleClaim</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/RouterModules/RouterModuleClaim.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
<a href="src/RouterModules/RouterModuleClaim.sol//src/interfaces/IRouterModule.sol/interface.IRouterModule.html">IRouterModule</a></p>
<p>An upgradeable module that allows for the claim of rewards from a given reward vault</p>
<h2 id="state-variables-1"><a class="header" href="#state-variables-1">State Variables</a></h2>
<h3 id="name"><a class="header" href="#name">name</a></h3>
<pre><code class="language-solidity">string public constant name = type(RouterModuleClaim).name;
</code></pre>
<h3 id="version"><a class="header" href="#version">version</a></h3>
<pre><code class="language-solidity">string public constant version = &quot;1.0.0&quot;;
</code></pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<h3 id="claim-1"><a class="header" href="#claim-1">claim</a></h3>
<p>Claim rewards from the reward vault</p>
<pre><code class="language-solidity">function claim(address rewardVault, address[] calldata tokens, address receiver)
    external
    returns (uint256[] memory amounts);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>rewardVault</code></td><td><code>address</code></td><td>The address of the reward vault to call</td></tr>
<tr><td><code>tokens</code></td><td><code>address[]</code></td><td>The array of tokens to claim</td></tr>
<tr><td><code>receiver</code></td><td><code>address</code></td><td>The address to receive the rewards</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="routermoduledeposit"><a class="header" href="#routermoduledeposit">RouterModuleDeposit</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/RouterModules/RouterModuleDeposit.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
<a href="src/RouterModules/RouterModuleDeposit.sol//src/interfaces/IRouterModule.sol/interface.IRouterModule.html">IRouterModule</a></p>
<p>An upgradeable module that allows for the deposit of assets into a given reward vault</p>
<h2 id="state-variables-2"><a class="header" href="#state-variables-2">State Variables</a></h2>
<h3 id="name-1"><a class="header" href="#name-1">name</a></h3>
<pre><code class="language-solidity">string public constant name = type(RouterModuleDeposit).name;
</code></pre>
<h3 id="version-1"><a class="header" href="#version-1">version</a></h3>
<pre><code class="language-solidity">string public constant version = &quot;1.0.0&quot;;
</code></pre>
<h2 id="functions-1"><a class="header" href="#functions-1">Functions</a></h2>
<h3 id="deposit-1"><a class="header" href="#deposit-1">deposit</a></h3>
<p>Deposit assets into the reward vault</p>
<p><strong>Notes:</strong></p>
<ul>
<li>
<p>throws: ZeroAddress if the account is the zero address</p>
</li>
<li>
<p>throws: SafeERC20FailedOperation if the account does not have enough allowance
for the reward vault to transfer the assets</p>
</li>
</ul>
<pre><code class="language-solidity">function deposit(address rewardVault, address receiver, uint256 assets) public returns (uint256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>rewardVault</code></td><td><code>address</code></td><td>The address of the reward vault to call</td></tr>
<tr><td><code>receiver</code></td><td><code>address</code></td><td></td></tr>
<tr><td><code>assets</code></td><td><code>uint256</code></td><td>The amount of assets to deposit</td></tr>
</tbody></table>
</div>
<h3 id="deposit-2"><a class="header" href="#deposit-2">deposit</a></h3>
<p>Deposit assets into the reward vault</p>
<p><strong>Notes:</strong></p>
<ul>
<li>
<p>throws: ZeroAddress if the account is the zero address</p>
</li>
<li>
<p>throws: SafeERC20FailedOperation if the account does not have enough allowance
for the reward vault to transfer the assets</p>
</li>
</ul>
<pre><code class="language-solidity">function deposit(address rewardVault, address receiver, uint256 assets, address referrer) public returns (uint256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>rewardVault</code></td><td><code>address</code></td><td>The address of the reward vault to call</td></tr>
<tr><td><code>receiver</code></td><td><code>address</code></td><td></td></tr>
<tr><td><code>assets</code></td><td><code>uint256</code></td><td>The amount of assets to deposit</td></tr>
<tr><td><code>referrer</code></td><td><code>address</code></td><td>The address of the referrer</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="routermodulemigrationcurve"><a class="header" href="#routermodulemigrationcurve">RouterModuleMigrationCurve</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/RouterModules/RouterModuleMigrationCurve.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
<a href="src/RouterModules/RouterModuleMigrationCurve.sol//src/interfaces/IRouterModule.sol/interface.IRouterModule.html">IRouterModule</a></p>
<h2 id="state-variables-3"><a class="header" href="#state-variables-3">State Variables</a></h2>
<h3 id="name-2"><a class="header" href="#name-2">name</a></h3>
<pre><code class="language-solidity">string public constant name = type(RouterModuleMigrationCurve).name;
</code></pre>
<h3 id="version-2"><a class="header" href="#version-2">version</a></h3>
<pre><code class="language-solidity">string public constant version = &quot;1.0.0&quot;;
</code></pre>
<h2 id="functions-2"><a class="header" href="#functions-2">Functions</a></h2>
<h3 id="migrate"><a class="header" href="#migrate">migrate</a></h3>
<p>Migrates shares from a liquidity gauge to a reward vault</p>
<p><em>The account must have approved the token to the router contract</em></p>
<pre><code class="language-solidity">function migrate(address from, address to, uint256 shares) external;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>from</code></td><td><code>address</code></td><td>The address of the old vault</td></tr>
<tr><td><code>to</code></td><td><code>address</code></td><td>The address of the new reward vault</td></tr>
<tr><td><code>shares</code></td><td><code>uint256</code></td><td>The number of shares to migrate</td></tr>
</tbody></table>
</div>
<h2 id="errors"><a class="header" href="#errors">Errors</a></h2>
<h3 id="vaultnotcompatible"><a class="header" href="#vaultnotcompatible">VaultNotCompatible</a></h3>
<pre><code class="language-solidity">error VaultNotCompatible();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ivault"><a class="header" href="#ivault">IVault</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/RouterModules/RouterModuleMigrationStakeDAOV1.sol">Git Source</a></p>
<h2 id="functions-3"><a class="header" href="#functions-3">Functions</a></h2>
<h3 id="token"><a class="header" href="#token">token</a></h3>
<pre><code class="language-solidity">function token() external view returns (address);
</code></pre>
<h3 id="withdraw-1"><a class="header" href="#withdraw-1">withdraw</a></h3>
<pre><code class="language-solidity">function withdraw(uint256 shares) external;
</code></pre>
<h3 id="liquiditygauge"><a class="header" href="#liquiditygauge">liquidityGauge</a></h3>
<pre><code class="language-solidity">function liquidityGauge() external view returns (address);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="routermodulemigrationstakedaov1"><a class="header" href="#routermodulemigrationstakedaov1">RouterModuleMigrationStakeDAOV1</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/RouterModules/RouterModuleMigrationStakeDAOV1.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
<a href="src/RouterModules/RouterModuleMigrationStakeDAOV1.sol//src/interfaces/IRouterModule.sol/interface.IRouterModule.html">IRouterModule</a></p>
<h2 id="state-variables-4"><a class="header" href="#state-variables-4">State Variables</a></h2>
<h3 id="name-3"><a class="header" href="#name-3">name</a></h3>
<pre><code class="language-solidity">string public constant name = type(RouterModuleMigrationStakeDAOV1).name;
</code></pre>
<h3 id="version-3"><a class="header" href="#version-3">version</a></h3>
<pre><code class="language-solidity">string public constant version = &quot;1.0.0&quot;;
</code></pre>
<h2 id="functions-4"><a class="header" href="#functions-4">Functions</a></h2>
<h3 id="migrate-1"><a class="header" href="#migrate-1">migrate</a></h3>
<p>Migrates shares from a liquidity gauge to a reward vault</p>
<p><em>The account must have approved the token to the router contract</em></p>
<pre><code class="language-solidity">function migrate(address from, address to, uint256 shares) external;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>from</code></td><td><code>address</code></td><td>The address of the old vault</td></tr>
<tr><td><code>to</code></td><td><code>address</code></td><td>The address of the new reward vault</td></tr>
<tr><td><code>shares</code></td><td><code>uint256</code></td><td>The number of shares to migrate</td></tr>
</tbody></table>
</div>
<h2 id="errors-1"><a class="header" href="#errors-1">Errors</a></h2>
<h3 id="vaultnotcompatible-1"><a class="header" href="#vaultnotcompatible-1">VaultNotCompatible</a></h3>
<pre><code class="language-solidity">error VaultNotCompatible();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="routermodulemigrationyearn"><a class="header" href="#routermodulemigrationyearn">RouterModuleMigrationYearn</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/RouterModules/RouterModuleMigrationYearn.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
<a href="src/RouterModules/RouterModuleMigrationYearn.sol//src/interfaces/IRouterModule.sol/interface.IRouterModule.html">IRouterModule</a></p>
<h2 id="state-variables-5"><a class="header" href="#state-variables-5">State Variables</a></h2>
<h3 id="name-4"><a class="header" href="#name-4">name</a></h3>
<pre><code class="language-solidity">string public constant name = type(RouterModuleMigrationYearn).name;
</code></pre>
<h3 id="version-4"><a class="header" href="#version-4">version</a></h3>
<pre><code class="language-solidity">string public constant version = &quot;1.0.0&quot;;
</code></pre>
<h2 id="functions-5"><a class="header" href="#functions-5">Functions</a></h2>
<h3 id="migrate-2"><a class="header" href="#migrate-2">migrate</a></h3>
<p>Migrates shares from convex to a reward vault</p>
<p><em>The account must have approved the token to the router contract</em></p>
<pre><code class="language-solidity">function migrate(address from, address to, uint256 shares) external;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>from</code></td><td><code>address</code></td><td>The address of the old vault</td></tr>
<tr><td><code>to</code></td><td><code>address</code></td><td>The address of the new reward vault</td></tr>
<tr><td><code>shares</code></td><td><code>uint256</code></td><td>The number of shares to migrate</td></tr>
</tbody></table>
</div>
<h2 id="errors-2"><a class="header" href="#errors-2">Errors</a></h2>
<h3 id="vaultnotcompatible-2"><a class="header" href="#vaultnotcompatible-2">VaultNotCompatible</a></h3>
<pre><code class="language-solidity">error VaultNotCompatible();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iyearnvault"><a class="header" href="#iyearnvault">IYearnVault</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/RouterModules/RouterModuleMigrationYearn.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
IERC20</p>
<h2 id="functions-6"><a class="header" href="#functions-6">Functions</a></h2>
<h3 id="withdraw-2"><a class="header" href="#withdraw-2">withdraw</a></h3>
<pre><code class="language-solidity">function withdraw(uint256 maxShares) external returns (uint256);
</code></pre>
<h3 id="token-1"><a class="header" href="#token-1">token</a></h3>
<pre><code class="language-solidity">function token() external view returns (address);
</code></pre>
<h3 id="transferfrom"><a class="header" href="#transferfrom">transferFrom</a></h3>
<pre><code class="language-solidity">function transferFrom(address from, address to, uint256 amount) external returns (bool);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="routermodulewithdraw"><a class="header" href="#routermodulewithdraw">RouterModuleWithdraw</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/RouterModules/RouterModuleWithdraw.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
<a href="src/RouterModules/RouterModuleWithdraw.sol//src/interfaces/IRouterModule.sol/interface.IRouterModule.html">IRouterModule</a></p>
<p>An upgradeable module that allows for the withdrawal of assets from a given reward vault</p>
<h2 id="state-variables-6"><a class="header" href="#state-variables-6">State Variables</a></h2>
<h3 id="name-5"><a class="header" href="#name-5">name</a></h3>
<pre><code class="language-solidity">string public constant name = type(RouterModuleWithdraw).name;
</code></pre>
<h3 id="version-5"><a class="header" href="#version-5">version</a></h3>
<pre><code class="language-solidity">string public constant version = &quot;1.0.0&quot;;
</code></pre>
<h2 id="functions-7"><a class="header" href="#functions-7">Functions</a></h2>
<h3 id="withdraw-3"><a class="header" href="#withdraw-3">withdraw</a></h3>
<p>Withdraws <code>assets</code> from the vault to <code>receiver</code> by burning shares from <code>owner</code>.</p>
<p><em><code>owner</code> must allow the <code>rewardVault</code> to spend the <code>assets</code></em></p>
<p><strong>Note:</strong>
throws: NotApproved if the Router is not allowed to withdraw the assets</p>
<pre><code class="language-solidity">function withdraw(address rewardVault, uint256 assets, address receiver) external returns (uint256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>rewardVault</code></td><td><code>address</code></td><td>The address of the reward vault to call</td></tr>
<tr><td><code>assets</code></td><td><code>uint256</code></td><td>The amount of assets to withdraw.</td></tr>
<tr><td><code>receiver</code></td><td><code>address</code></td><td>The address to receive the assets. If the receiver is the zero address, the assets will be sent to the owner.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>_ The amount of assets withdrawn.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="contents-1"><a class="header" href="#contents-1">Contents</a></h1>
<ul>
<li><a href="src/integrations//src/integrations/curve">curve</a></li>
<li><a href="src/integrations//src/integrations/yieldnest">yieldnest</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contents-2"><a class="header" href="#contents-2">Contents</a></h1>
<ul>
<li><a href="src/integrations/curve/ConvexSidecar.sol/contract.ConvexSidecar.html">ConvexSidecar</a></li>
<li><a href="src/integrations/curve/ConvexSidecarFactory.sol/contract.ConvexSidecarFactory.html">ConvexSidecarFactory</a></li>
<li><a href="src/integrations/curve/CurveAllocator.sol/contract.CurveAllocator.html">CurveAllocator</a></li>
<li><a href="src/integrations/curve/CurveFactory.sol/contract.CurveFactory.html">CurveFactory</a></li>
<li><a href="src/integrations/curve/CurveStrategy.sol/contract.CurveStrategy.html">CurveStrategy</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="convexsidecar"><a class="header" href="#convexsidecar">ConvexSidecar</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/integrations/curve/ConvexSidecar.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
<a href="src/integrations/curve/ConvexSidecar.sol//src/Sidecar.sol/abstract.Sidecar.html">Sidecar</a></p>
<p>Sidecar for Convex.</p>
<p><em>For each PID, a minimal proxy is deployed using this contract as implementation.</em></p>
<h2 id="state-variables-7"><a class="header" href="#state-variables-7">State Variables</a></h2>
<h3 id="curve_protocol_id"><a class="header" href="#curve_protocol_id">CURVE_PROTOCOL_ID</a></h3>
<p>The bytes4 ID of the Curve protocol</p>
<p><em>Used to identify the Curve protocol in the registry</em></p>
<pre><code class="language-solidity">bytes4 private constant CURVE_PROTOCOL_ID = bytes4(keccak256(&quot;CURVE&quot;));
</code></pre>
<h3 id="cvx"><a class="header" href="#cvx">CVX</a></h3>
<p>Convex Reward Token address.</p>
<pre><code class="language-solidity">IERC20 public constant CVX = IERC20(CurveProtocol.CONVEX_TOKEN);
</code></pre>
<h3 id="booster"><a class="header" href="#booster">BOOSTER</a></h3>
<p>Convex Booster address.</p>
<pre><code class="language-solidity">IBooster public constant BOOSTER = IBooster(CurveProtocol.CONVEX_BOOSTER);
</code></pre>
<h2 id="functions-8"><a class="header" href="#functions-8">Functions</a></h2>
<h3 id="asset"><a class="header" href="#asset">asset</a></h3>
<p>Staking token address.</p>
<pre><code class="language-solidity">function asset() public view override returns (IERC20 _asset);
</code></pre>
<h3 id="rewardreceiver"><a class="header" href="#rewardreceiver">rewardReceiver</a></h3>
<pre><code class="language-solidity">function rewardReceiver() public view override returns (address _rewardReceiver);
</code></pre>
<h3 id="baserewardpool"><a class="header" href="#baserewardpool">baseRewardPool</a></h3>
<p>Staking Convex LP contract address.</p>
<pre><code class="language-solidity">function baseRewardPool() public view returns (IBaseRewardPool _baseRewardPool);
</code></pre>
<h3 id="pid"><a class="header" href="#pid">pid</a></h3>
<p>Identifier of the pool on Convex.</p>
<pre><code class="language-solidity">function pid() public view returns (uint256 _pid);
</code></pre>
<h3 id="constructor"><a class="header" href="#constructor">constructor</a></h3>
<pre><code class="language-solidity">constructor(address _accountant, address _protocolController)
    Sidecar(CURVE_PROTOCOL_ID, _accountant, _protocolController);
</code></pre>
<h3 id="_initialize"><a class="header" href="#_initialize">_initialize</a></h3>
<p>Initialize the contract by approving the ConvexCurve booster to spend the LP token.</p>
<pre><code class="language-solidity">function _initialize() internal override;
</code></pre>
<h3 id="_deposit"><a class="header" href="#_deposit">_deposit</a></h3>
<p>Deposit LP token into Convex.</p>
<p><em>The reason there's an empty address parameter is to keep flexibility for future implementations.
Not all fallbacks will be minimal proxies, so we need to keep the same function signature.
Only callable by the strategy.</em></p>
<pre><code class="language-solidity">function _deposit(uint256 amount) internal override;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>amount</code></td><td><code>uint256</code></td><td>Amount of LP token to deposit.</td></tr>
</tbody></table>
</div>
<h3 id="_withdraw"><a class="header" href="#_withdraw">_withdraw</a></h3>
<p>Withdraw LP token from Convex.</p>
<pre><code class="language-solidity">function _withdraw(uint256 amount, address receiver) internal override;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>amount</code></td><td><code>uint256</code></td><td>Amount of LP token to withdraw.</td></tr>
<tr><td><code>receiver</code></td><td><code>address</code></td><td>Address to receive the LP token.</td></tr>
</tbody></table>
</div>
<h3 id="_claim"><a class="header" href="#_claim">_claim</a></h3>
<p>Claim rewards from Convex.</p>
<pre><code class="language-solidity">function _claim() internal override returns (uint256 rewardTokenAmount);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>rewardTokenAmount</code></td><td><code>uint256</code></td><td>Amount of reward token claimed.</td></tr>
</tbody></table>
</div>
<h3 id="balanceof"><a class="header" href="#balanceof">balanceOf</a></h3>
<p>Get the balance of the LP token on Convex held by this contract.</p>
<pre><code class="language-solidity">function balanceOf() public view override returns (uint256);
</code></pre>
<h3 id="getrewardtokens"><a class="header" href="#getrewardtokens">getRewardTokens</a></h3>
<p>Get the reward tokens from the base reward pool.</p>
<pre><code class="language-solidity">function getRewardTokens() public view override returns (address[] memory);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>address[]</code></td><td>Array of all extra reward tokens.</td></tr>
</tbody></table>
</div>
<h3 id="getpendingrewards"><a class="header" href="#getpendingrewards">getPendingRewards</a></h3>
<p>Get the amount of reward token earned by the strategy.</p>
<pre><code class="language-solidity">function getPendingRewards() public view override returns (uint256);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>The amount of reward token earned by the strategy.</td></tr>
</tbody></table>
</div>
<h3 id="claimextrarewards"><a class="header" href="#claimextrarewards">claimExtraRewards</a></h3>
<pre><code class="language-solidity">function claimExtraRewards() external;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="convexsidecarfactory"><a class="header" href="#convexsidecarfactory">ConvexSidecarFactory</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/integrations/curve/ConvexSidecarFactory.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
<a href="src/integrations/curve/ConvexSidecarFactory.sol//src/SidecarFactory.sol/abstract.SidecarFactory.html">SidecarFactory</a></p>
<p>Factory contract for deploying ConvexSidecar instances</p>
<p><em>Creates deterministic minimal proxies for ConvexSidecar implementation</em></p>
<h2 id="state-variables-8"><a class="header" href="#state-variables-8">State Variables</a></h2>
<h3 id="curve_protocol_id-1"><a class="header" href="#curve_protocol_id-1">CURVE_PROTOCOL_ID</a></h3>
<p>The bytes4 ID of the Convex protocol</p>
<p><em>Used to identify the Convex protocol in the registry</em></p>
<pre><code class="language-solidity">bytes4 private constant CURVE_PROTOCOL_ID = bytes4(keccak256(&quot;CURVE&quot;));
</code></pre>
<h3 id="booster-1"><a class="header" href="#booster-1">BOOSTER</a></h3>
<p>Convex Booster contract address</p>
<pre><code class="language-solidity">IBooster public constant BOOSTER = IBooster(CurveProtocol.CONVEX_BOOSTER);
</code></pre>
<h2 id="functions-9"><a class="header" href="#functions-9">Functions</a></h2>
<h3 id="constructor-1"><a class="header" href="#constructor-1">constructor</a></h3>
<p>Constructor</p>
<pre><code class="language-solidity">constructor(address _implementation, address _protocolController)
    SidecarFactory(CURVE_PROTOCOL_ID, _implementation, _protocolController);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_implementation</code></td><td><code>address</code></td><td>Address of the sidecar implementation</td></tr>
<tr><td><code>_protocolController</code></td><td><code>address</code></td><td>Address of the protocol controller</td></tr>
</tbody></table>
</div>
<h3 id="create"><a class="header" href="#create">create</a></h3>
<p>Convenience function to create a sidecar with a uint256 pid parameter</p>
<pre><code class="language-solidity">function create(address gauge, uint256 pid) external returns (address sidecar);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td></td></tr>
<tr><td><code>pid</code></td><td><code>uint256</code></td><td>Pool ID in Convex</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>sidecar</code></td><td><code>address</code></td><td>Address of the created sidecar</td></tr>
</tbody></table>
</div>
<h3 id="_isvalidgauge"><a class="header" href="#_isvalidgauge">_isValidGauge</a></h3>
<p>Validates the gauge and arguments for Convex</p>
<pre><code class="language-solidity">function _isValidGauge(address gauge, bytes memory args) internal view override;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The gauge to validate</td></tr>
<tr><td><code>args</code></td><td><code>bytes</code></td><td>The arguments containing the pool ID</td></tr>
</tbody></table>
</div>
<h3 id="_create"><a class="header" href="#_create">_create</a></h3>
<p>Creates a ConvexSidecar for a gauge</p>
<pre><code class="language-solidity">function _create(address gauge, bytes memory args) internal override returns (address sidecarAddress);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The gauge to create a sidecar for</td></tr>
<tr><td><code>args</code></td><td><code>bytes</code></td><td>The arguments containing the pool ID</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>sidecarAddress</code></td><td><code>address</code></td><td>Address of the created sidecar</td></tr>
</tbody></table>
</div>
<h2 id="errors-3"><a class="header" href="#errors-3">Errors</a></h2>
<h3 id="poolshutdown"><a class="header" href="#poolshutdown">PoolShutdown</a></h3>
<p>Error emitted when the pool is shutdown</p>
<pre><code class="language-solidity">error PoolShutdown();
</code></pre>
<h3 id="vaultnotdeployed"><a class="header" href="#vaultnotdeployed">VaultNotDeployed</a></h3>
<p>Error emitted when the reward receiver is not set</p>
<pre><code class="language-solidity">error VaultNotDeployed();
</code></pre>
<h3 id="invalidarguments"><a class="header" href="#invalidarguments">InvalidArguments</a></h3>
<p>Error emitted when the arguments are invalid</p>
<pre><code class="language-solidity">error InvalidArguments();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="curveallocator"><a class="header" href="#curveallocator">CurveAllocator</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/integrations/curve/CurveAllocator.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
<a href="src/integrations/curve/CurveAllocator.sol//src/Allocator.sol/contract.Allocator.html">Allocator</a></p>
<p>Contract that calculates the optimal LP token allocation for StakeDAO Locker and Convex</p>
<h2 id="state-variables-9"><a class="header" href="#state-variables-9">State Variables</a></h2>
<h3 id="convex_sidecar_factory"><a class="header" href="#convex_sidecar_factory">CONVEX_SIDECAR_FACTORY</a></h3>
<p>Address of the Convex Sidecar Factory contract</p>
<pre><code class="language-solidity">ISidecarFactory public immutable CONVEX_SIDECAR_FACTORY;
</code></pre>
<h3 id="boost_delegation_v3"><a class="header" href="#boost_delegation_v3">BOOST_DELEGATION_V3</a></h3>
<p>Address of the Curve Boost Delegation V3 contract</p>
<pre><code class="language-solidity">address public constant BOOST_DELEGATION_V3 = CurveProtocol.VE_BOOST;
</code></pre>
<h3 id="convex_boost_holder"><a class="header" href="#convex_boost_holder">CONVEX_BOOST_HOLDER</a></h3>
<p>Address of the Convex Boost Holder contract</p>
<pre><code class="language-solidity">address public constant CONVEX_BOOST_HOLDER = CurveProtocol.CONVEX_PROXY;
</code></pre>
<h2 id="functions-10"><a class="header" href="#functions-10">Functions</a></h2>
<h3 id="constructor-2"><a class="header" href="#constructor-2">constructor</a></h3>
<p>Initializes the CurveAllocator contract</p>
<pre><code class="language-solidity">constructor(address _locker, address _gateway, address _convexSidecarFactory) Allocator(_locker, _gateway);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_locker</code></td><td><code>address</code></td><td>Address of the StakeDAO Liquidity Locker</td></tr>
<tr><td><code>_gateway</code></td><td><code>address</code></td><td>Address of the gateway contract</td></tr>
<tr><td><code>_convexSidecarFactory</code></td><td><code>address</code></td><td>Address of the Convex Sidecar Factory contract</td></tr>
</tbody></table>
</div>
<h3 id="getdepositallocation"><a class="header" href="#getdepositallocation">getDepositAllocation</a></h3>
<p>Determines how funds should be allocated during a deposit</p>
<p><em>In this base implementation, all funds are directed to the LOCKER</em></p>
<pre><code class="language-solidity">function getDepositAllocation(address asset, address gauge, uint256 amount)
    public
    view
    override
    returns (Allocation memory alloc);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>asset</code></td><td><code>address</code></td><td>The address of the asset contract</td></tr>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The address of the gauge contract</td></tr>
<tr><td><code>amount</code></td><td><code>uint256</code></td><td>The amount of tokens to deposit</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>alloc</code></td><td><code>Allocation</code></td><td>Allocation struct containing the allocation details</td></tr>
</tbody></table>
</div>
<h3 id="getwithdrawalallocation"><a class="header" href="#getwithdrawalallocation">getWithdrawalAllocation</a></h3>
<p>Determines how funds should be allocated during a withdrawal</p>
<p><em>In this base implementation, all funds are withdrawn from the LOCKER</em></p>
<pre><code class="language-solidity">function getWithdrawalAllocation(address asset, address gauge, uint256 amount)
    public
    view
    override
    returns (Allocation memory alloc);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>asset</code></td><td><code>address</code></td><td></td></tr>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The address of the gauge contract</td></tr>
<tr><td><code>amount</code></td><td><code>uint256</code></td><td>The amount of tokens to withdraw</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>alloc</code></td><td><code>Allocation</code></td><td>Allocation struct containing the allocation details</td></tr>
</tbody></table>
</div>
<h3 id="getrebalancedallocation"><a class="header" href="#getrebalancedallocation">getRebalancedAllocation</a></h3>
<p>Determines how funds should be allocated during a rebalance</p>
<p><em>In this base implementation, rebalancing uses the same allocation as deposits</em></p>
<pre><code class="language-solidity">function getRebalancedAllocation(address asset, address gauge, uint256 totalBalance)
    public
    view
    override
    returns (Allocation memory alloc);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>asset</code></td><td><code>address</code></td><td></td></tr>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The address of the gauge contract</td></tr>
<tr><td><code>totalBalance</code></td><td><code>uint256</code></td><td></td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>alloc</code></td><td><code>Allocation</code></td><td>Allocation struct containing the allocation details</td></tr>
</tbody></table>
</div>
<h3 id="getallocationtargets"><a class="header" href="#getallocationtargets">getAllocationTargets</a></h3>
<p>Returns the list of target addresses for a specific gauge
gauge The address of the gauge contract (unused in this implementation)</p>
<p><em>In this base implementation, the only target is the LOCKER</em></p>
<pre><code class="language-solidity">function getAllocationTargets(address gauge) public view override returns (address[] memory);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>address[]</code></td><td>An array containing the target addresses</td></tr>
</tbody></table>
</div>
<h3 id="_targets"><a class="header" href="#_targets">_targets</a></h3>
<p><em>Returns the pair <code>[sidecar, LOCKER]</code> used by allocation targets.</em></p>
<pre><code class="language-solidity">function _targets(address sidecar) private view returns (address[] memory arr);
</code></pre>
<h3 id="_pair"><a class="header" href="#_pair">_pair</a></h3>
<p><em>Utility to allocate a twoelement uint256 array.</em></p>
<pre><code class="language-solidity">function _pair(uint256 a0, uint256 a1) private pure returns (uint256[] memory arr);
</code></pre>
<h3 id="_computelockerallocation"><a class="header" href="#_computelockerallocation">_computeLockerAllocation</a></h3>
<p><em>Computes the optimal amount to allocate to the locker based on ratio of veBoosts.</em></p>
<pre><code class="language-solidity">function _computeLockerAllocation(uint256 totalBalance) private view returns (uint256 lockerAmt);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>totalBalance</code></td><td><code>uint256</code></td><td>The total balance of the gauge.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>lockerAmt</code></td><td><code>uint256</code></td><td>The optimal amount to allocate to the locker.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="curvefactory"><a class="header" href="#curvefactory">CurveFactory</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/integrations/curve/CurveFactory.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
<a href="src/integrations/curve/CurveFactory.sol//src/Factory.sol/abstract.Factory.html">Factory</a></p>
<h2 id="state-variables-10"><a class="header" href="#state-variables-10">State Variables</a></h2>
<h3 id="curve_protocol_id-2"><a class="header" href="#curve_protocol_id-2">CURVE_PROTOCOL_ID</a></h3>
<p>The bytes4 ID of the Curve protocol</p>
<p><em>Used to identify the Curve protocol in the registry</em></p>
<pre><code class="language-solidity">bytes4 private constant CURVE_PROTOCOL_ID = bytes4(keccak256(&quot;CURVE&quot;));
</code></pre>
<h3 id="gauge_controller"><a class="header" href="#gauge_controller">GAUGE_CONTROLLER</a></h3>
<p>Curve Gauge Controller.</p>
<pre><code class="language-solidity">IGaugeController public constant GAUGE_CONTROLLER = IGaugeController(CurveProtocol.GAUGE_CONTROLLER);
</code></pre>
<h3 id="cvx-1"><a class="header" href="#cvx-1">CVX</a></h3>
<p>CVX token address.</p>
<pre><code class="language-solidity">address public constant CVX = CurveProtocol.CONVEX_TOKEN;
</code></pre>
<h3 id="old_strategy"><a class="header" href="#old_strategy">OLD_STRATEGY</a></h3>
<p>Address of the old strategy.</p>
<pre><code class="language-solidity">address public constant OLD_STRATEGY = CurveLocker.STRATEGY;
</code></pre>
<h3 id="booster-2"><a class="header" href="#booster-2">BOOSTER</a></h3>
<p>Convex Booster.</p>
<pre><code class="language-solidity">address public immutable BOOSTER = CurveProtocol.CONVEX_BOOSTER;
</code></pre>
<h3 id="convex_sidecar_factory-1"><a class="header" href="#convex_sidecar_factory-1">CONVEX_SIDECAR_FACTORY</a></h3>
<p>Convex Minimal Proxy Factory for Only Boost.</p>
<pre><code class="language-solidity">address public immutable CONVEX_SIDECAR_FACTORY;
</code></pre>
<h2 id="functions-11"><a class="header" href="#functions-11">Functions</a></h2>
<h3 id="constructor-3"><a class="header" href="#constructor-3">constructor</a></h3>
<pre><code class="language-solidity">constructor(
    address protocolController,
    address vaultImplementation,
    address rewardReceiverImplementation,
    address locker,
    address gateway,
    address convexSidecarFactory
) Factory(protocolController, vaultImplementation, rewardReceiverImplementation, CURVE_PROTOCOL_ID, locker, gateway);
</code></pre>
<h3 id="create-1"><a class="header" href="#create-1">create</a></h3>
<p>Create a new vault.</p>
<pre><code class="language-solidity">function create(uint256 _pid) external returns (address vault, address rewardReceiver, address sidecar);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_pid</code></td><td><code>uint256</code></td><td>Pool id.</td></tr>
</tbody></table>
</div>
<h3 id="_isvalidtoken"><a class="header" href="#_isvalidtoken">_isValidToken</a></h3>
<pre><code class="language-solidity">function _isValidToken(address _token) internal view virtual override returns (bool);
</code></pre>
<h3 id="_isvalidgauge-1"><a class="header" href="#_isvalidgauge-1">_isValidGauge</a></h3>
<pre><code class="language-solidity">function _isValidGauge(address _gauge) internal view virtual override returns (bool);
</code></pre>
<h3 id="_isvaliddeployment"><a class="header" href="#_isvaliddeployment">_isValidDeployment</a></h3>
<p>Check if the gauge is shutdown in the old strategy.</p>
<p><em>If the gauge is shutdown, we can deploy a new strategy.</em></p>
<pre><code class="language-solidity">function _isValidDeployment(address _gauge) internal view virtual override returns (bool);
</code></pre>
<h3 id="_getasset"><a class="header" href="#_getasset">_getAsset</a></h3>
<pre><code class="language-solidity">function _getAsset(address _gauge) internal view virtual override returns (address);
</code></pre>
<h3 id="_setuprewardtokens"><a class="header" href="#_setuprewardtokens">_setupRewardTokens</a></h3>
<pre><code class="language-solidity">function _setupRewardTokens(address _vault, address _gauge, address _rewardReceiver) internal virtual override;
</code></pre>
<h3 id="_setrewardreceiver"><a class="header" href="#_setrewardreceiver">_setRewardReceiver</a></h3>
<pre><code class="language-solidity">function _setRewardReceiver(address _gauge, address _rewardReceiver) internal override;
</code></pre>
<h3 id="_initializevault"><a class="header" href="#_initializevault">_initializeVault</a></h3>
<pre><code class="language-solidity">function _initializeVault(address, address _asset, address _gauge) internal override;
</code></pre>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<h3 id="vaultdeployed"><a class="header" href="#vaultdeployed">VaultDeployed</a></h3>
<p>Event emitted when a vault is deployed.</p>
<pre><code class="language-solidity">event VaultDeployed(address gauge, address vault, address rewardReceiver, address sidecar);
</code></pre>
<h2 id="errors-4"><a class="header" href="#errors-4">Errors</a></h2>
<h3 id="setrewardreceiverfailed"><a class="header" href="#setrewardreceiverfailed">SetRewardReceiverFailed</a></h3>
<p>Error thrown when the set reward receiver fails.</p>
<pre><code class="language-solidity">error SetRewardReceiverFailed();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="curvestrategy"><a class="header" href="#curvestrategy">CurveStrategy</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/integrations/curve/CurveStrategy.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
<a href="src/integrations/curve/CurveStrategy.sol//src/Strategy.sol/abstract.Strategy.html">Strategy</a></p>
<p>A strategy implementation for interacting with Curve protocol gauges</p>
<p>*Extends the base Strategy contract with Curve-specific functionality
Key responsibilities:</p>
<ul>
<li>Syncs and tracks pending rewards from Curve gauges and Sidecar contracts</li>
<li>Handles deposits and withdrawals through Curve liquidity gauges and Sidecar contracts</li>
<li>Executes transactions through a gateway/module manager pattern*</li>
</ul>
<h2 id="state-variables-11"><a class="header" href="#state-variables-11">State Variables</a></h2>
<h3 id="minter"><a class="header" href="#minter">MINTER</a></h3>
<p>The address of the Curve Minter contract</p>
<p><em>Used to account for CRV tokens from gauge rewards</em></p>
<pre><code class="language-solidity">address public immutable MINTER;
</code></pre>
<h3 id="curve_protocol_id-3"><a class="header" href="#curve_protocol_id-3">CURVE_PROTOCOL_ID</a></h3>
<p>The bytes4 ID of the Curve protocol</p>
<p><em>Used to identify the Curve protocol in the registry</em></p>
<pre><code class="language-solidity">bytes4 private constant CURVE_PROTOCOL_ID = bytes4(keccak256(&quot;CURVE&quot;));
</code></pre>
<h2 id="functions-12"><a class="header" href="#functions-12">Functions</a></h2>
<h3 id="constructor-4"><a class="header" href="#constructor-4">constructor</a></h3>
<p>Initializes the CurveStrategy contract</p>
<pre><code class="language-solidity">constructor(address _registry, address _locker, address _gateway, address _minter)
    Strategy(_registry, CURVE_PROTOCOL_ID, _locker, _gateway);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_registry</code></td><td><code>address</code></td><td>The address of the protocol controller registry</td></tr>
<tr><td><code>_locker</code></td><td><code>address</code></td><td>The address of the locker contract</td></tr>
<tr><td><code>_gateway</code></td><td><code>address</code></td><td>The address of the gateway contract</td></tr>
<tr><td><code>_minter</code></td><td><code>address</code></td><td></td></tr>
</tbody></table>
</div>
<h3 id="_checkpointrewards"><a class="header" href="#_checkpointrewards">_checkpointRewards</a></h3>
<p>Syncs and calculates pending rewards from a Curve gauge</p>
<p><em>Retrieves allocation targets and calculates pending rewards for each target</em></p>
<pre><code class="language-solidity">function _checkpointRewards(address gauge) internal override returns (PendingRewards memory pendingRewards);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The address of the Curve gauge to sync</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pendingRewards</code></td><td><code>PendingRewards</code></td><td>A struct containing the total and fee subject pending rewards</td></tr>
</tbody></table>
</div>
<h3 id="_deposit-1"><a class="header" href="#_deposit-1">_deposit</a></h3>
<p>Deposits tokens into a Curve gauge</p>
<p><em>Executes a deposit transaction through the gateway/module manager</em></p>
<pre><code class="language-solidity">function _deposit(address, address gauge, uint256 amount) internal override;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>address</code></td><td></td></tr>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The address of the Curve gauge to deposit into</td></tr>
<tr><td><code>amount</code></td><td><code>uint256</code></td><td>The amount of tokens to deposit</td></tr>
</tbody></table>
</div>
<h3 id="_withdraw-1"><a class="header" href="#_withdraw-1">_withdraw</a></h3>
<p>Withdraws tokens from a Curve gauge</p>
<p><em>Executes a withdraw transaction through the gateway/module manager</em></p>
<pre><code class="language-solidity">function _withdraw(address asset, address gauge, uint256 amount, address receiver) internal override;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>asset</code></td><td><code>address</code></td><td></td></tr>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The address of the Curve gauge to withdraw from</td></tr>
<tr><td><code>amount</code></td><td><code>uint256</code></td><td>The amount of tokens to withdraw</td></tr>
<tr><td><code>receiver</code></td><td><code>address</code></td><td>The address that will receive the withdrawn tokens</td></tr>
</tbody></table>
</div>
<h3 id="_harvestlocker"><a class="header" href="#_harvestlocker">_harvestLocker</a></h3>
<p>Harvests rewards from a Curve gauge</p>
<pre><code class="language-solidity">function _harvestLocker(address gauge, bytes memory) internal override returns (uint256 rewardAmount);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The address of the Curve gauge to harvest from</td></tr>
<tr><td><code>&lt;none&gt;</code></td><td><code>bytes</code></td><td></td></tr>
</tbody></table>
</div>
<h2 id="errors-5"><a class="header" href="#errors-5">Errors</a></h2>
<h3 id="mintfailed"><a class="header" href="#mintfailed">MintFailed</a></h3>
<p>Error thrown when the mint fails.</p>
<pre><code class="language-solidity">error MintFailed();
</code></pre>
<h3 id="checkpointfailed"><a class="header" href="#checkpointfailed">CheckpointFailed</a></h3>
<p>Error thrown when the checkpoint fails.</p>
<pre><code class="language-solidity">error CheckpointFailed();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contents-3"><a class="header" href="#contents-3">Contents</a></h1>
<ul>
<li><a href="src/integrations/yieldnest/YieldnestAutocompoundedVault.sol/contract.YieldnestAutocompoundedVault.html">YieldnestAutocompoundedVault</a></li>
<li><a href="src/integrations/yieldnest/YieldnestOFT.sol/contract.YieldnestOFT.html">YieldnestOFT</a></li>
<li><a href="src/integrations/yieldnest/YieldnestOFTAdapter.sol/contract.YieldnestOFTAdapter.html">YieldnestOFTAdapter</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yieldnestautocompoundedvault"><a class="header" href="#yieldnestautocompoundedvault">YieldnestAutocompoundedVault</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/integrations/yieldnest/YieldnestAutocompoundedVault.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
<a href="src/integrations/yieldnest/YieldnestAutocompoundedVault.sol//src/AutocompoundedVault.sol/contract.AutocompoundedVault.html">AutocompoundedVault</a></p>
<p>This contract is a fully compliant ERC4626 streaming yield-bearing vault for sdYND tokens.
The rewards are streamed linearly over a fixed period and the vault is autocompounded.</p>
<h2 id="functions-13"><a class="header" href="#functions-13">Functions</a></h2>
<h3 id="constructor-5"><a class="header" href="#constructor-5">constructor</a></h3>
<p>Initialize the the streaming period, the asset and the shares token</p>
<p><em>sdYND is the asset contract while asdYND is the shares token</em></p>
<pre><code class="language-solidity">constructor(address _owner)
    AutocompoundedVault(7 days, IERC20(YieldnestProtocol.SDYND), &quot;Autocompounded Stake DAO YND&quot;, &quot;asdYND&quot;, _owner);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_owner</code></td><td><code>address</code></td><td>The owner of the vault</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="yieldnestoft"><a class="header" href="#yieldnestoft">YieldnestOFT</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/integrations/yieldnest/YieldnestOFT.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
OFT</p>
<p>This contract represents the omnichain asdYND token on BSC, enabling minting and burning via LayerZero V2 bridging.</p>
<p>*This contract is a LayerZero OFT (Omnichain Fungible Token) for asdYND (Autocompounded Stake DAO YND shares).
It allows users to receive asdYND tokens bridged from Ethereum mainnet and to bridge them back by burning.
LayerZero is an interoperability protocol for secure cross-chain messaging and bridging. It allows tokens to move between networks
without wrapping or middlechains, using a unified supply model.
What token is minted here?</p>
<ul>
<li>This contract mints and burns the omnichain asdYND ERC20 token on BSC.</li>
<li>The token is minted when asdYND is bridged in from mainnet, and burned when bridging out.
How does bridging work?</li>
</ul>
<ol>
<li>On Ethereum mainnet, users lock asdYND tokens in the <code>YieldnestOFTAdapter</code> contract to initiate a bridge to BSC.</li>
<li>This contract receives a LayerZero message and mints the equivalent amount of asdYND tokens to the recipient on BSC.</li>
<li>To bridge back, users call the <code>send</code> function (inherited from OFT) to burn their asdYND tokens and initiate a bridge back to mainnet.
For more details on LayerZero and OFT bridging, see:
https://docs.layerzero.network/v2/developers/evm/oft/quickstart*</li>
</ol>
<h2 id="functions-14"><a class="header" href="#functions-14">Functions</a></h2>
<h3 id="constructor-6"><a class="header" href="#constructor-6">constructor</a></h3>
<p>Deploys the Yieldnest OFT for asdYND bridging on BSC.</p>
<pre><code class="language-solidity">constructor(address _delegate, address _owner)
    OFT(&quot;Autocompounded Stake DAO YND&quot;, &quot;asdYND&quot;, Common.LAYERZERO_ENDPOINT, _delegate)
    Ownable(_owner);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_delegate</code></td><td><code>address</code></td><td>The admin for LayerZero configuration.</td></tr>
<tr><td><code>_owner</code></td><td><code>address</code></td><td>The owner of the contract</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="yieldnestoftadapter"><a class="header" href="#yieldnestoftadapter">YieldnestOFTAdapter</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/integrations/yieldnest/YieldnestOFTAdapter.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
OFTAdapter</p>
<p>SPDX-License-Identifier: GPL-3.0</p>
<p>This contract enables bridging of asdYND tokens from Ethereum mainnet to BSC using LayerZero V2.</p>
<p>*This contract is a LayerZero OFTAdapter for the asdYND token (Autocompounded Stake DAO YND shares).
It allows users to lock their asdYND tokens on mainnet and bridge them to BSC, where they are minted as omnichain asdYND tokens.
LayerZero is an interoperability protocol for secure cross-chain messaging and bridging. It allows tokens to move between networks
without wrapping or middlechains, using a unified supply model.
How to lock and bridge asdYND to BSC</p>
<ol>
<li>Approve this contract to spend your asdYND tokens.</li>
<li>Call the <code>send</code> function (inherited from OFTAdapter) with the appropriate parameters to bridge your tokens to BSC.</li>
</ol>
<ul>
<li>The contract will lock your asdYND tokens on mainnet and initiate a LayerZero message to BSC.</li>
</ul>
<ol start="3">
<li>On BSC, the paired OFT contract will mint the equivalent amount of asdYND tokens to the recipient.
Where are tokens bridged to?</li>
</ol>
<ul>
<li>Currently, this contract is configured to bridge asdYND tokens only to the BSC chain (destination chain).</li>
<li>The BSC OFT contract address must be set as a trusted remote in LayerZero configuration.
For more details on LayerZero and OFT bridging, see:
https:///docs.layerzero.network/v2/developers/evm/oft/quickstart*</li>
</ul>
<h2 id="functions-15"><a class="header" href="#functions-15">Functions</a></h2>
<h3 id="constructor-7"><a class="header" href="#constructor-7">constructor</a></h3>
<p>Deploys the Yieldnest OFTAdapter for asdYND bridging.</p>
<pre><code class="language-solidity">constructor(address _token, address _delegate, address _owner)
    OFTAdapter(_token, Common.LAYERZERO_ENDPOINT, _delegate)
    Ownable(_owner);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_token</code></td><td><code>address</code></td><td>The address of the asdYND ERC20 token to be locked and bridged.</td></tr>
<tr><td><code>_delegate</code></td><td><code>address</code></td><td>The admin for LayerZero configuration.</td></tr>
<tr><td><code>_owner</code></td><td><code>address</code></td><td>The owner of the contract</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="contents-4"><a class="header" href="#contents-4">Contents</a></h1>
<ul>
<li><a href="src/interfaces/IAccountant.sol/interface.IAccountant.html">IAccountant</a></li>
<li><a href="src/interfaces/IAllocator.sol/interface.IAllocator.html">IAllocator</a></li>
<li><a href="src/interfaces/IBalanceProvider.sol/interface.IBalanceProvider.html">IBalanceProvider</a></li>
<li><a href="src/interfaces/IProtocolContext.sol/interface.IProtocolContext.html">IProtocolContext</a></li>
<li><a href="src/interfaces/IProtocolController.sol/interface.IProtocolController.html">IProtocolController</a></li>
<li><a href="src/interfaces/IRewardReceiver.sol/interface.IRewardReceiver.html">IRewardReceiver</a></li>
<li><a href="src/interfaces/IRewardVault.sol/interface.IRewardVault.html">IRewardVault</a></li>
<li><a href="src/interfaces/IRouter.sol/interface.IRouter.html">IRouter</a></li>
<li><a href="src/interfaces/IRouterModule.sol/interface.IRouterModule.html">IRouterModule</a></li>
<li><a href="src/interfaces/ISidecar.sol/interface.ISidecar.html">ISidecar</a></li>
<li><a href="src/interfaces/ISidecarFactory.sol/interface.ISidecarFactory.html">ISidecarFactory</a></li>
<li><a href="src/interfaces/IStrategy.sol/interface.IStrategy.html">IStrategy</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iaccountant"><a class="header" href="#iaccountant">IAccountant</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/interfaces/IAccountant.sol">Git Source</a></p>
<h2 id="functions-16"><a class="header" href="#functions-16">Functions</a></h2>
<h3 id="checkpoint"><a class="header" href="#checkpoint">checkpoint</a></h3>
<pre><code class="language-solidity">function checkpoint(
    address gauge,
    address from,
    address to,
    uint128 amount,
    IStrategy.PendingRewards calldata pendingRewards,
    IStrategy.HarvestPolicy policy
) external;
</code></pre>
<h3 id="checkpoint-1"><a class="header" href="#checkpoint-1">checkpoint</a></h3>
<pre><code class="language-solidity">function checkpoint(
    address gauge,
    address from,
    address to,
    uint128 amount,
    IStrategy.PendingRewards calldata pendingRewards,
    IStrategy.HarvestPolicy policy,
    address referrer
) external;
</code></pre>
<h3 id="totalsupply"><a class="header" href="#totalsupply">totalSupply</a></h3>
<pre><code class="language-solidity">function totalSupply(address asset) external view returns (uint128);
</code></pre>
<h3 id="balanceof-1"><a class="header" href="#balanceof-1">balanceOf</a></h3>
<pre><code class="language-solidity">function balanceOf(address asset, address account) external view returns (uint128);
</code></pre>
<h3 id="claim-2"><a class="header" href="#claim-2">claim</a></h3>
<pre><code class="language-solidity">function claim(address[] calldata _vaults, bytes[] calldata harvestData) external;
</code></pre>
<h3 id="claim-3"><a class="header" href="#claim-3">claim</a></h3>
<pre><code class="language-solidity">function claim(address[] calldata _vaults, bytes[] calldata harvestData, address receiver) external;
</code></pre>
<h3 id="claim-4"><a class="header" href="#claim-4">claim</a></h3>
<pre><code class="language-solidity">function claim(address[] calldata _vaults, address account, bytes[] calldata harvestData) external;
</code></pre>
<h3 id="claim-5"><a class="header" href="#claim-5">claim</a></h3>
<pre><code class="language-solidity">function claim(address[] calldata _vaults, address account, bytes[] calldata harvestData, address receiver) external;
</code></pre>
<h3 id="claimprotocolfees"><a class="header" href="#claimprotocolfees">claimProtocolFees</a></h3>
<pre><code class="language-solidity">function claimProtocolFees() external;
</code></pre>
<h3 id="harvest"><a class="header" href="#harvest">harvest</a></h3>
<pre><code class="language-solidity">function harvest(address[] calldata _vaults, bytes[] calldata _harvestData, address _receiver) external;
</code></pre>
<h3 id="reward_token"><a class="header" href="#reward_token">REWARD_TOKEN</a></h3>
<pre><code class="language-solidity">function REWARD_TOKEN() external view returns (address);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iallocator"><a class="header" href="#iallocator">IAllocator</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/interfaces/IAllocator.sol">Git Source</a></p>
<h2 id="functions-17"><a class="header" href="#functions-17">Functions</a></h2>
<h3 id="getdepositallocation-1"><a class="header" href="#getdepositallocation-1">getDepositAllocation</a></h3>
<pre><code class="language-solidity">function getDepositAllocation(address asset, address gauge, uint256 amount) external view returns (Allocation memory);
</code></pre>
<h3 id="getwithdrawalallocation-1"><a class="header" href="#getwithdrawalallocation-1">getWithdrawalAllocation</a></h3>
<pre><code class="language-solidity">function getWithdrawalAllocation(address asset, address gauge, uint256 amount)
    external
    view
    returns (Allocation memory);
</code></pre>
<h3 id="getrebalancedallocation-1"><a class="header" href="#getrebalancedallocation-1">getRebalancedAllocation</a></h3>
<pre><code class="language-solidity">function getRebalancedAllocation(address asset, address gauge, uint256 amount)
    external
    view
    returns (Allocation memory);
</code></pre>
<h3 id="getallocationtargets-1"><a class="header" href="#getallocationtargets-1">getAllocationTargets</a></h3>
<pre><code class="language-solidity">function getAllocationTargets(address gauge) external view returns (address[] memory);
</code></pre>
<h2 id="structs"><a class="header" href="#structs">Structs</a></h2>
<h3 id="allocation"><a class="header" href="#allocation">Allocation</a></h3>
<pre><code class="language-solidity">struct Allocation {
    address asset;
    address gauge;
    address[] targets;
    uint256[] amounts;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ibalanceprovider"><a class="header" href="#ibalanceprovider">IBalanceProvider</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/interfaces/IBalanceProvider.sol">Git Source</a></p>
<h2 id="functions-18"><a class="header" href="#functions-18">Functions</a></h2>
<h3 id="balanceof-2"><a class="header" href="#balanceof-2">balanceOf</a></h3>
<pre><code class="language-solidity">function balanceOf(address _address) external view returns (uint256);
</code></pre>
<h3 id="totalsupply-1"><a class="header" href="#totalsupply-1">totalSupply</a></h3>
<pre><code class="language-solidity">function totalSupply() external view returns (uint256);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iprotocolcontext"><a class="header" href="#iprotocolcontext">IProtocolContext</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/interfaces/IProtocolContext.sol">Git Source</a></p>
<h2 id="functions-19"><a class="header" href="#functions-19">Functions</a></h2>
<h3 id="protocol_id"><a class="header" href="#protocol_id">PROTOCOL_ID</a></h3>
<pre><code class="language-solidity">function PROTOCOL_ID() external view returns (bytes4);
</code></pre>
<h3 id="locker"><a class="header" href="#locker">LOCKER</a></h3>
<pre><code class="language-solidity">function LOCKER() external view returns (address);
</code></pre>
<h3 id="gateway"><a class="header" href="#gateway">GATEWAY</a></h3>
<pre><code class="language-solidity">function GATEWAY() external view returns (address);
</code></pre>
<h3 id="accountant"><a class="header" href="#accountant">ACCOUNTANT</a></h3>
<pre><code class="language-solidity">function ACCOUNTANT() external view returns (address);
</code></pre>
<h3 id="reward_token-1"><a class="header" href="#reward_token-1">REWARD_TOKEN</a></h3>
<pre><code class="language-solidity">function REWARD_TOKEN() external view returns (address);
</code></pre>
<h3 id="protocol_controller"><a class="header" href="#protocol_controller">PROTOCOL_CONTROLLER</a></h3>
<pre><code class="language-solidity">function PROTOCOL_CONTROLLER() external view returns (IProtocolController);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iprotocolcontroller"><a class="header" href="#iprotocolcontroller">IProtocolController</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/interfaces/IProtocolController.sol">Git Source</a></p>
<p>SPDX-License-Identifier: BUSL-1.1</p>
<h2 id="functions-20"><a class="header" href="#functions-20">Functions</a></h2>
<h3 id="vaults"><a class="header" href="#vaults">vaults</a></h3>
<pre><code class="language-solidity">function vaults(address) external view returns (address);
</code></pre>
<h3 id="asset-1"><a class="header" href="#asset-1">asset</a></h3>
<pre><code class="language-solidity">function asset(address) external view returns (address);
</code></pre>
<h3 id="rewardreceiver-1"><a class="header" href="#rewardreceiver-1">rewardReceiver</a></h3>
<pre><code class="language-solidity">function rewardReceiver(address) external view returns (address);
</code></pre>
<h3 id="allowed"><a class="header" href="#allowed">allowed</a></h3>
<pre><code class="language-solidity">function allowed(address, address, bytes4 selector) external view returns (bool);
</code></pre>
<h3 id="permissionsetters"><a class="header" href="#permissionsetters">permissionSetters</a></h3>
<pre><code class="language-solidity">function permissionSetters(address) external view returns (bool);
</code></pre>
<h3 id="isregistrar"><a class="header" href="#isregistrar">isRegistrar</a></h3>
<pre><code class="language-solidity">function isRegistrar(address) external view returns (bool);
</code></pre>
<h3 id="strategy"><a class="header" href="#strategy">strategy</a></h3>
<pre><code class="language-solidity">function strategy(bytes4 protocolId) external view returns (address);
</code></pre>
<h3 id="allocator"><a class="header" href="#allocator">allocator</a></h3>
<pre><code class="language-solidity">function allocator(bytes4 protocolId) external view returns (address);
</code></pre>
<h3 id="accountant-1"><a class="header" href="#accountant-1">accountant</a></h3>
<pre><code class="language-solidity">function accountant(bytes4 protocolId) external view returns (address);
</code></pre>
<h3 id="feereceiver"><a class="header" href="#feereceiver">feeReceiver</a></h3>
<pre><code class="language-solidity">function feeReceiver(bytes4 protocolId) external view returns (address);
</code></pre>
<h3 id="isshutdown"><a class="header" href="#isshutdown">isShutdown</a></h3>
<pre><code class="language-solidity">function isShutdown(address) external view returns (bool);
</code></pre>
<h3 id="isfullywithdrawn"><a class="header" href="#isfullywithdrawn">isFullyWithdrawn</a></h3>
<pre><code class="language-solidity">function isFullyWithdrawn(address) external view returns (bool);
</code></pre>
<h3 id="registervault"><a class="header" href="#registervault">registerVault</a></h3>
<pre><code class="language-solidity">function registerVault(address _gauge, address _vault, address _asset, address _rewardReceiver, bytes4 _protocolId)
    external;
</code></pre>
<h3 id="setvalidallocationtarget"><a class="header" href="#setvalidallocationtarget">setValidAllocationTarget</a></h3>
<pre><code class="language-solidity">function setValidAllocationTarget(address _gauge, address _target) external;
</code></pre>
<h3 id="removevalidallocationtarget"><a class="header" href="#removevalidallocationtarget">removeValidAllocationTarget</a></h3>
<pre><code class="language-solidity">function removeValidAllocationTarget(address _gauge, address _target) external;
</code></pre>
<h3 id="isvalidallocationtarget"><a class="header" href="#isvalidallocationtarget">isValidAllocationTarget</a></h3>
<pre><code class="language-solidity">function isValidAllocationTarget(address _gauge, address _target) external view returns (bool);
</code></pre>
<h3 id="shutdown"><a class="header" href="#shutdown">shutdown</a></h3>
<pre><code class="language-solidity">function shutdown(address _gauge) external;
</code></pre>
<h3 id="markgaugeasfullywithdrawn"><a class="header" href="#markgaugeasfullywithdrawn">markGaugeAsFullyWithdrawn</a></h3>
<pre><code class="language-solidity">function markGaugeAsFullyWithdrawn(address _gauge) external;
</code></pre>
<h3 id="setpermissionsetter"><a class="header" href="#setpermissionsetter">setPermissionSetter</a></h3>
<pre><code class="language-solidity">function setPermissionSetter(address _setter, bool _allowed) external;
</code></pre>
<h3 id="setpermission"><a class="header" href="#setpermission">setPermission</a></h3>
<pre><code class="language-solidity">function setPermission(address _contract, address _caller, bytes4 _selector, bool _allowed) external;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="irewardreceiver"><a class="header" href="#irewardreceiver">IRewardReceiver</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/interfaces/IRewardReceiver.sol">Git Source</a></p>
<h2 id="functions-21"><a class="header" href="#functions-21">Functions</a></h2>
<h3 id="distributerewards"><a class="header" href="#distributerewards">distributeRewards</a></h3>
<pre><code class="language-solidity">function distributeRewards() external;
</code></pre>
<h3 id="distributerewardtoken"><a class="header" href="#distributerewardtoken">distributeRewardToken</a></h3>
<pre><code class="language-solidity">function distributeRewardToken(IERC20 token) external;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="irewardvault"><a class="header" href="#irewardvault">IRewardVault</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/interfaces/IRewardVault.sol">Git Source</a></p>
<p>Interface for the RewardVault contract</p>
<h2 id="functions-22"><a class="header" href="#functions-22">Functions</a></h2>
<h3 id="addrewardtoken"><a class="header" href="#addrewardtoken">addRewardToken</a></h3>
<pre><code class="language-solidity">function addRewardToken(address rewardsToken, address distributor) external;
</code></pre>
<h3 id="depositrewards"><a class="header" href="#depositrewards">depositRewards</a></h3>
<pre><code class="language-solidity">function depositRewards(address _rewardsToken, uint128 _amount) external;
</code></pre>
<h3 id="deposit-3"><a class="header" href="#deposit-3">deposit</a></h3>
<pre><code class="language-solidity">function deposit(uint256 assets, address receiver, address referrer) external returns (uint256 shares);
</code></pre>
<h3 id="deposit-4"><a class="header" href="#deposit-4">deposit</a></h3>
<pre><code class="language-solidity">function deposit(address account, address receiver, uint256 assets, address referrer)
    external
    returns (uint256 shares);
</code></pre>
<h3 id="claim-6"><a class="header" href="#claim-6">claim</a></h3>
<pre><code class="language-solidity">function claim(address[] calldata tokens, address receiver) external returns (uint256[] memory amounts);
</code></pre>
<h3 id="claim-7"><a class="header" href="#claim-7">claim</a></h3>
<pre><code class="language-solidity">function claim(address account, address[] calldata tokens, address receiver)
    external
    returns (uint256[] memory amounts);
</code></pre>
<h3 id="getrewardsdistributor"><a class="header" href="#getrewardsdistributor">getRewardsDistributor</a></h3>
<pre><code class="language-solidity">function getRewardsDistributor(address token) external view returns (address);
</code></pre>
<h3 id="getlastupdatetime"><a class="header" href="#getlastupdatetime">getLastUpdateTime</a></h3>
<pre><code class="language-solidity">function getLastUpdateTime(address token) external view returns (uint32);
</code></pre>
<h3 id="getperiodfinish"><a class="header" href="#getperiodfinish">getPeriodFinish</a></h3>
<pre><code class="language-solidity">function getPeriodFinish(address token) external view returns (uint32);
</code></pre>
<h3 id="getrewardrate"><a class="header" href="#getrewardrate">getRewardRate</a></h3>
<pre><code class="language-solidity">function getRewardRate(address token) external view returns (uint128);
</code></pre>
<h3 id="getrewardpertokenstored"><a class="header" href="#getrewardpertokenstored">getRewardPerTokenStored</a></h3>
<pre><code class="language-solidity">function getRewardPerTokenStored(address token) external view returns (uint128);
</code></pre>
<h3 id="getrewardpertokenpaid"><a class="header" href="#getrewardpertokenpaid">getRewardPerTokenPaid</a></h3>
<pre><code class="language-solidity">function getRewardPerTokenPaid(address token, address account) external view returns (uint128);
</code></pre>
<h3 id="getclaimable"><a class="header" href="#getclaimable">getClaimable</a></h3>
<pre><code class="language-solidity">function getClaimable(address token, address account) external view returns (uint128);
</code></pre>
<h3 id="getrewardtokens-1"><a class="header" href="#getrewardtokens-1">getRewardTokens</a></h3>
<pre><code class="language-solidity">function getRewardTokens() external view returns (address[] memory);
</code></pre>
<h3 id="lasttimerewardapplicable"><a class="header" href="#lasttimerewardapplicable">lastTimeRewardApplicable</a></h3>
<pre><code class="language-solidity">function lastTimeRewardApplicable(address token) external view returns (uint256);
</code></pre>
<h3 id="rewardpertoken"><a class="header" href="#rewardpertoken">rewardPerToken</a></h3>
<pre><code class="language-solidity">function rewardPerToken(address token) external view returns (uint128);
</code></pre>
<h3 id="earned"><a class="header" href="#earned">earned</a></h3>
<pre><code class="language-solidity">function earned(address account, address token) external view returns (uint128);
</code></pre>
<h3 id="isrewardtoken"><a class="header" href="#isrewardtoken">isRewardToken</a></h3>
<pre><code class="language-solidity">function isRewardToken(address rewardToken) external view returns (bool);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="irouter"><a class="header" href="#irouter">IRouter</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/interfaces/IRouter.sol">Git Source</a></p>
<h2 id="functions-23"><a class="header" href="#functions-23">Functions</a></h2>
<h3 id="execute"><a class="header" href="#execute">execute</a></h3>
<pre><code class="language-solidity">function execute(bytes[] calldata data) external payable returns (bytes[] memory returnData);
</code></pre>
<h3 id="setmodule"><a class="header" href="#setmodule">setModule</a></h3>
<pre><code class="language-solidity">function setModule(uint8 identifier, address module) external;
</code></pre>
<h3 id="safesetmodule"><a class="header" href="#safesetmodule">safeSetModule</a></h3>
<pre><code class="language-solidity">function safeSetModule(uint8 identifier, address module) external;
</code></pre>
<h3 id="getmodule"><a class="header" href="#getmodule">getModule</a></h3>
<pre><code class="language-solidity">function getModule(uint8 identifier) external view returns (address module);
</code></pre>
<h3 id="getmodulename"><a class="header" href="#getmodulename">getModuleName</a></h3>
<pre><code class="language-solidity">function getModuleName(uint8 identifier) external view returns (string memory name);
</code></pre>
<h3 id="version-6"><a class="header" href="#version-6">version</a></h3>
<pre><code class="language-solidity">function version() external view returns (string memory version);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iroutermodule"><a class="header" href="#iroutermodule">IRouterModule</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/interfaces/IRouterModule.sol">Git Source</a></p>
<h2 id="functions-24"><a class="header" href="#functions-24">Functions</a></h2>
<h3 id="name-6"><a class="header" href="#name-6">name</a></h3>
<pre><code class="language-solidity">function name() external view returns (string memory name);
</code></pre>
<h3 id="version-7"><a class="header" href="#version-7">version</a></h3>
<pre><code class="language-solidity">function version() external view returns (string memory version);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="isidecar"><a class="header" href="#isidecar">ISidecar</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/interfaces/ISidecar.sol">Git Source</a></p>
<p>SPDX-License-Identifier: BUSL-1.1</p>
<h2 id="functions-25"><a class="header" href="#functions-25">Functions</a></h2>
<h3 id="balanceof-3"><a class="header" href="#balanceof-3">balanceOf</a></h3>
<pre><code class="language-solidity">function balanceOf() external view returns (uint256);
</code></pre>
<h3 id="deposit-5"><a class="header" href="#deposit-5">deposit</a></h3>
<pre><code class="language-solidity">function deposit(uint256 amount) external;
</code></pre>
<h3 id="withdraw-4"><a class="header" href="#withdraw-4">withdraw</a></h3>
<pre><code class="language-solidity">function withdraw(uint256 amount, address receiver) external;
</code></pre>
<h3 id="getpendingrewards-1"><a class="header" href="#getpendingrewards-1">getPendingRewards</a></h3>
<pre><code class="language-solidity">function getPendingRewards() external view returns (uint256);
</code></pre>
<h3 id="getrewardtokens-2"><a class="header" href="#getrewardtokens-2">getRewardTokens</a></h3>
<pre><code class="language-solidity">function getRewardTokens() external view returns (address[] memory);
</code></pre>
<h3 id="claim-8"><a class="header" href="#claim-8">claim</a></h3>
<pre><code class="language-solidity">function claim() external returns (uint256);
</code></pre>
<h3 id="asset-2"><a class="header" href="#asset-2">asset</a></h3>
<pre><code class="language-solidity">function asset() external view returns (IERC20);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="isidecarfactory"><a class="header" href="#isidecarfactory">ISidecarFactory</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/interfaces/ISidecarFactory.sol">Git Source</a></p>
<h2 id="functions-26"><a class="header" href="#functions-26">Functions</a></h2>
<h3 id="sidecar"><a class="header" href="#sidecar">sidecar</a></h3>
<pre><code class="language-solidity">function sidecar(address gauge) external view returns (address);
</code></pre>
<h3 id="create-2"><a class="header" href="#create-2">create</a></h3>
<pre><code class="language-solidity">function create(address token, bytes memory args) external returns (address);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="istrategy"><a class="header" href="#istrategy">IStrategy</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/interfaces/IStrategy.sol">Git Source</a></p>
<h2 id="functions-27"><a class="header" href="#functions-27">Functions</a></h2>
<h3 id="deposit-6"><a class="header" href="#deposit-6">deposit</a></h3>
<pre><code class="language-solidity">function deposit(IAllocator.Allocation calldata allocation, HarvestPolicy policy)
    external
    returns (PendingRewards memory pendingRewards);
</code></pre>
<h3 id="withdraw-5"><a class="header" href="#withdraw-5">withdraw</a></h3>
<pre><code class="language-solidity">function withdraw(IAllocator.Allocation calldata allocation, HarvestPolicy policy, address receiver)
    external
    returns (PendingRewards memory pendingRewards);
</code></pre>
<h3 id="balanceof-4"><a class="header" href="#balanceof-4">balanceOf</a></h3>
<pre><code class="language-solidity">function balanceOf(address gauge) external view returns (uint256 balance);
</code></pre>
<h3 id="harvest-1"><a class="header" href="#harvest-1">harvest</a></h3>
<pre><code class="language-solidity">function harvest(address gauge, bytes calldata extraData) external returns (PendingRewards memory pendingRewards);
</code></pre>
<h3 id="flush"><a class="header" href="#flush">flush</a></h3>
<pre><code class="language-solidity">function flush() external;
</code></pre>
<h2 id="structs-1"><a class="header" href="#structs-1">Structs</a></h2>
<h3 id="pendingrewards"><a class="header" href="#pendingrewards">PendingRewards</a></h3>
<pre><code class="language-solidity">struct PendingRewards {
    uint128 feeSubjectAmount;
    uint128 totalAmount;
}
</code></pre>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<h3 id="harvestpolicy"><a class="header" href="#harvestpolicy">HarvestPolicy</a></h3>
<p>The policy for harvesting rewards.</p>
<pre><code class="language-solidity">enum HarvestPolicy {
    CHECKPOINT,
    HARVEST
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contents-5"><a class="header" href="#contents-5">Contents</a></h1>
<ul>
<li><a href="src/libraries/ImmutableArgsParser.sol/library.ImmutableArgsParser.html">ImmutableArgsParser</a></li>
<li><a href="src/libraries/LayerZeroEID.sol/library.LayerZeroEID.html">LayerZeroEID</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="immutableargsparser"><a class="header" href="#immutableargsparser">ImmutableArgsParser</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/libraries/ImmutableArgsParser.sol">Git Source</a></p>
<p>A library for reading immutable arguments from a clone.</p>
<h2 id="functions-28"><a class="header" href="#functions-28">Functions</a></h2>
<h3 id="readaddress"><a class="header" href="#readaddress">readAddress</a></h3>
<p><em>Safely read an <code>address</code> from <code>clone</code>'s immutable args at <code>offset</code>.</em></p>
<pre><code class="language-solidity">function readAddress(address clone, uint256 offset) internal view returns (address result);
</code></pre>
<h3 id="readuint256"><a class="header" href="#readuint256">readUint256</a></h3>
<p><em>Safely read a <code>uint256</code> from <code>clone</code>'s immutable args at <code>offset</code>.</em></p>
<pre><code class="language-solidity">function readUint256(address clone, uint256 offset) internal view returns (uint256 result);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layerzeroeid"><a class="header" href="#layerzeroeid">LayerZeroEID</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/libraries/LayerZeroEID.sol">Git Source</a></p>
<h2 id="state-variables-12"><a class="header" href="#state-variables-12">State Variables</a></h2>
<h3 id="mainnet_eid"><a class="header" href="#mainnet_eid">MAINNET_EID</a></h3>
<pre><code class="language-solidity">uint32 internal constant MAINNET_EID = 30101;
</code></pre>
<h3 id="polygon_eid"><a class="header" href="#polygon_eid">POLYGON_EID</a></h3>
<pre><code class="language-solidity">uint32 internal constant POLYGON_EID = 30109;
</code></pre>
<h3 id="base_eid"><a class="header" href="#base_eid">BASE_EID</a></h3>
<pre><code class="language-solidity">uint32 internal constant BASE_EID = 30184;
</code></pre>
<h3 id="linea_eid"><a class="header" href="#linea_eid">LINEA_EID</a></h3>
<pre><code class="language-solidity">uint32 internal constant LINEA_EID = 30183;
</code></pre>
<h3 id="bsc_eid"><a class="header" href="#bsc_eid">BSC_EID</a></h3>
<pre><code class="language-solidity">uint32 internal constant BSC_EID = 30102;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contents-6"><a class="header" href="#contents-6">Contents</a></h1>
<ul>
<li><a href="src/merkl/UniversalBoostRegistry.sol/contract.UniversalBoostRegistry.html">UniversalBoostRegistry</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="universalboostregistry"><a class="header" href="#universalboostregistry">UniversalBoostRegistry</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/merkl/UniversalBoostRegistry.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
Ownable2Step</p>
<p>A registry to keep track of the Boosts rented by the users, per protocol, to work with Merkl.</p>
<p>*Merkl will use this registry to know which Boosts are rented by the users, per protocol, and allocate according rewards,
minus the protocol fees (if any), set by this contract.
Key responsibilities:</p>
<ul>
<li>Tracks boost rental status for users across different protocols</li>
<li>Manages protocol-specific fee configurations with time-delayed updates</li>
<li>Provides a secure fee update mechanism with owner controls and delay periods</li>
<li>Integrates with Merkl for reward distribution calculations
The contract implements a two-phase fee update system:</li>
</ul>
<ol>
<li>Queue: Owner queues new protocol configurations</li>
<li>Commit: After delay period, configurations can be committed to take effect*</li>
</ol>
<h2 id="state-variables-13"><a class="header" href="#state-variables-13">State Variables</a></h2>
<h3 id="max_fee_percent"><a class="header" href="#max_fee_percent">MAX_FEE_PERCENT</a></h3>
<p>The maximum fee percent (40%).</p>
<pre><code class="language-solidity">uint128 public constant MAX_FEE_PERCENT = 0.4e18;
</code></pre>
<h3 id="delayperiod"><a class="header" href="#delayperiod">delayPeriod</a></h3>
<p>Delay period for new fees to take effect.</p>
<p><em>This prevents immediate fee changes and provides users time to react to fee updates.</em></p>
<pre><code class="language-solidity">uint64 public delayPeriod = 1 days;
</code></pre>
<h3 id="queueddelayperiod"><a class="header" href="#queueddelayperiod">queuedDelayPeriod</a></h3>
<p>Queued delay period that will become active after commitment.</p>
<pre><code class="language-solidity">uint64 public queuedDelayPeriod;
</code></pre>
<h3 id="delayperiodqueuedtimestamp"><a class="header" href="#delayperiodqueuedtimestamp">delayPeriodQueuedTimestamp</a></h3>
<p>Timestamp when the queued delay period can be committed.</p>
<pre><code class="language-solidity">uint64 public delayPeriodQueuedTimestamp;
</code></pre>
<h3 id="protocolconfig"><a class="header" href="#protocolconfig">protocolConfig</a></h3>
<p>Mapping of protocol ID to protocol configuration.</p>
<p><em>Contains both active and queued configurations in a single mapping.
Use queuedTimestamp to determine if a configuration is pending.</em></p>
<pre><code class="language-solidity">mapping(bytes4 protocolId =&gt; ProtocolConfig config) public protocolConfig;
</code></pre>
<h3 id="isrentingboost"><a class="header" href="#isrentingboost">isRentingBoost</a></h3>
<p>Mapping of account to protocol ID to boost rental status.</p>
<p><em>Tracks whether a user has rented a boost for a specific protocol.
True means the user is currently renting a boost, false means they are not.</em></p>
<pre><code class="language-solidity">mapping(address account =&gt; mapping(bytes4 protocolId =&gt; bool status)) public isRentingBoost;
</code></pre>
<h2 id="functions-29"><a class="header" href="#functions-29">Functions</a></h2>
<h3 id="constructor-8"><a class="header" href="#constructor-8">constructor</a></h3>
<p>Initializes the UniversalBoostRegistry contract.</p>
<p><em>Sets the deployer as the initial owner using Ownable2Step pattern.</em></p>
<pre><code class="language-solidity">constructor(address initialOwner) Ownable(initialOwner);
</code></pre>
<h3 id="rentboost"><a class="header" href="#rentboost">rentBoost</a></h3>
<p>Rents a boost for a given protocol.</p>
<p><em>Updates the rental status to true and emits a BoostRented event.
This function can be called by any user to rent a boost for themselves.</em></p>
<pre><code class="language-solidity">function rentBoost(bytes4 protocolId) public;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>protocolId</code></td><td><code>bytes4</code></td><td>The protocol ID for which to rent the boost.</td></tr>
</tbody></table>
</div>
<h3 id="returnboost"><a class="header" href="#returnboost">returnBoost</a></h3>
<p>Returns a boost for a given protocol.</p>
<p><em>Updates the rental status to false and emits a BoostReturned event.
This function can be called by any user to return their rented boost.</em></p>
<pre><code class="language-solidity">function returnBoost(bytes4 protocolId) public;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>protocolId</code></td><td><code>bytes4</code></td><td>The protocol ID for which to return the boost.</td></tr>
</tbody></table>
</div>
<h3 id="queuenewprotocolconfig"><a class="header" href="#queuenewprotocolconfig">queueNewProtocolConfig</a></h3>
<p>Queues a new protocol config for a given protocol ID.</p>
<p><em>Implements the first phase of the two-phase fee update mechanism.
Only the owner can queue new configurations. The configuration will not
take effect immediately - it must be committed after the delay period.
Preserves active configuration values until commitment.</em></p>
<p><strong>Notes:</strong></p>
<ul>
<li>
<p>throws: OwnableUnauthorizedAccount If caller is not the owner.</p>
</li>
<li>
<p>throws: FeeExceedsMaximum If the protocol fee exceeds the maximum allowed.</p>
</li>
</ul>
<pre><code class="language-solidity">function queueNewProtocolConfig(bytes4 protocolId, uint128 protocolFees) public onlyOwner;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>protocolId</code></td><td><code>bytes4</code></td><td>The protocol ID for which to queue the new configuration.</td></tr>
<tr><td><code>protocolFees</code></td><td><code>uint128</code></td><td>The protocol fee percentage to queue (scaled by 1e18).</td></tr>
</tbody></table>
</div>
<h3 id="setfeereceiver"><a class="header" href="#setfeereceiver">setFeeReceiver</a></h3>
<p>Set a new fee receiver for a given protocol.</p>
<p><em>This function can only be called by the owner.</em></p>
<pre><code class="language-solidity">function setFeeReceiver(bytes4 protocolId, address feeReceiver) public onlyOwner;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>protocolId</code></td><td><code>bytes4</code></td><td>The protocol ID for which to set the new fee receiver.</td></tr>
<tr><td><code>feeReceiver</code></td><td><code>address</code></td><td>The new fee receiver address.</td></tr>
</tbody></table>
</div>
<h3 id="queuedelayperiod"><a class="header" href="#queuedelayperiod">queueDelayPeriod</a></h3>
<p>Queues a new delay period.</p>
<p><em>This function can only be called by the owner. The new delay period
will only take effect after the current delay period has passed.
This prevents bypassing the delay mechanism by reducing the delay period.</em></p>
<pre><code class="language-solidity">function queueDelayPeriod(uint64 newDelayPeriod) public onlyOwner;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>newDelayPeriod</code></td><td><code>uint64</code></td><td>The new delay period to queue.</td></tr>
</tbody></table>
</div>
<h3 id="commitdelayperiod"><a class="header" href="#commitdelayperiod">commitDelayPeriod</a></h3>
<p>Commits the queued delay period.</p>
<p><em>Can be called by anyone once the delay period has passed.</em></p>
<pre><code class="language-solidity">function commitDelayPeriod() public;
</code></pre>
<h3 id="commitprotocolconfig"><a class="header" href="#commitprotocolconfig">commitProtocolConfig</a></h3>
<p>Commits a new protocol config for a given protocol ID.</p>
<p><em>Implements the second phase of the two-phase fee update mechanism.
Can only be called after the delay period has passed since the configuration was queued.
This function can be called by anyone once the delay period has elapsed.
Moves queued values to active values and clears the queue.</em></p>
<p><strong>Notes:</strong></p>
<ul>
<li>
<p>throws: DelayPeriodNotPassed If the delay period since queuing hasn't elapsed.</p>
</li>
<li>
<p>throws: NoQueuedConfig If there is no queued configuration to commit.</p>
</li>
</ul>
<pre><code class="language-solidity">function commitProtocolConfig(bytes4 protocolId) public;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>protocolId</code></td><td><code>bytes4</code></td><td>The protocol ID for which to commit the new configuration.</td></tr>
</tbody></table>
</div>
<h3 id="hasqueuedconfig"><a class="header" href="#hasqueuedconfig">hasQueuedConfig</a></h3>
<p>Returns whether a protocol configuration is currently queued and pending.</p>
<pre><code class="language-solidity">function hasQueuedConfig(bytes4 protocolId) external view returns (bool);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>protocolId</code></td><td><code>bytes4</code></td><td>The protocol ID to check.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>bool</code></td><td>_ True if there is a queued configuration pending commitment.</td></tr>
</tbody></table>
</div>
<h3 id="getcommittimestamp"><a class="header" href="#getcommittimestamp">getCommitTimestamp</a></h3>
<p>Returns the timestamp when a configuration can be committed.</p>
<pre><code class="language-solidity">function getCommitTimestamp(bytes4 protocolId) external view returns (uint64);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>protocolId</code></td><td><code>bytes4</code></td><td>The protocol ID to check.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint64</code></td><td>_ The timestamp when the configuration can be committed (0 if no queued config).</td></tr>
</tbody></table>
</div>
<h3 id="hasqueueddelayperiod"><a class="header" href="#hasqueueddelayperiod">hasQueuedDelayPeriod</a></h3>
<p>Returns whether a delay period is currently queued and pending.</p>
<pre><code class="language-solidity">function hasQueuedDelayPeriod() external view returns (bool);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>bool</code></td><td>_ True if there is a queued delay period pending commitment.</td></tr>
</tbody></table>
</div>
<h3 id="getdelayperiodcommittimestamp"><a class="header" href="#getdelayperiodcommittimestamp">getDelayPeriodCommitTimestamp</a></h3>
<p>Returns the timestamp when the queued delay period can be committed.</p>
<pre><code class="language-solidity">function getDelayPeriodCommitTimestamp() external view returns (uint64);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint64</code></td><td>_ The timestamp when the delay period can be committed (0 if no queued delay period).</td></tr>
</tbody></table>
</div>
<h2 id="events-1"><a class="header" href="#events-1">Events</a></h2>
<h3 id="boostrented"><a class="header" href="#boostrented">BoostRented</a></h3>
<p>Event emitted when a boost is rented.</p>
<pre><code class="language-solidity">event BoostRented(address indexed account, bytes4 indexed protocolId);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>account</code></td><td><code>address</code></td><td>The address that rented the boost.</td></tr>
<tr><td><code>protocolId</code></td><td><code>bytes4</code></td><td>The protocol ID for which the boost was rented.</td></tr>
</tbody></table>
</div>
<h3 id="boostreturned"><a class="header" href="#boostreturned">BoostReturned</a></h3>
<p>Event emitted when a boost is returned.</p>
<pre><code class="language-solidity">event BoostReturned(address indexed account, bytes4 indexed protocolId);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>account</code></td><td><code>address</code></td><td>The address that returned the boost.</td></tr>
<tr><td><code>protocolId</code></td><td><code>bytes4</code></td><td>The protocol ID for which the boost was returned.</td></tr>
</tbody></table>
</div>
<h3 id="newprotocolconfigqueued"><a class="header" href="#newprotocolconfigqueued">NewProtocolConfigQueued</a></h3>
<p>Event emitted when a new protocol config is queued.</p>
<pre><code class="language-solidity">event NewProtocolConfigQueued(bytes4 indexed protocolId, uint128 protocolFees, uint64 queuedTimestamp);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>protocolId</code></td><td><code>bytes4</code></td><td>The protocol ID for which the config was queued.</td></tr>
<tr><td><code>protocolFees</code></td><td><code>uint128</code></td><td>The queued protocol fee percentage.</td></tr>
<tr><td><code>queuedTimestamp</code></td><td><code>uint64</code></td><td>The timestamp when the configuration was queued.</td></tr>
</tbody></table>
</div>
<h3 id="protocolconfigcommitted"><a class="header" href="#protocolconfigcommitted">ProtocolConfigCommitted</a></h3>
<p>Event emitted when a protocol config is committed.</p>
<pre><code class="language-solidity">event ProtocolConfigCommitted(bytes4 indexed protocolId, uint128 protocolFees, uint64 committedTimestamp);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>protocolId</code></td><td><code>bytes4</code></td><td>The protocol ID for which the config was committed.</td></tr>
<tr><td><code>protocolFees</code></td><td><code>uint128</code></td><td>The committed protocol fee percentage.</td></tr>
<tr><td><code>committedTimestamp</code></td><td><code>uint64</code></td><td>The timestamp when the configuration was committed.</td></tr>
</tbody></table>
</div>
<h3 id="delayperiodqueued"><a class="header" href="#delayperiodqueued">DelayPeriodQueued</a></h3>
<p>Event emitted when a new delay period is queued.</p>
<pre><code class="language-solidity">event DelayPeriodQueued(uint64 newDelayPeriod, uint64 queuedTimestamp);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>newDelayPeriod</code></td><td><code>uint64</code></td><td>The new delay period.</td></tr>
<tr><td><code>queuedTimestamp</code></td><td><code>uint64</code></td><td>The timestamp when it can be committed.</td></tr>
</tbody></table>
</div>
<h3 id="delayperiodcommitted"><a class="header" href="#delayperiodcommitted">DelayPeriodCommitted</a></h3>
<p>Event emitted when the delay period is committed.</p>
<pre><code class="language-solidity">event DelayPeriodCommitted(uint64 newDelayPeriod, uint64 committedTimestamp);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>newDelayPeriod</code></td><td><code>uint64</code></td><td>The new delay period.</td></tr>
<tr><td><code>committedTimestamp</code></td><td><code>uint64</code></td><td>The timestamp when it was committed.</td></tr>
</tbody></table>
</div>
<h2 id="errors-6"><a class="header" href="#errors-6">Errors</a></h2>
<h3 id="noqueuedconfig"><a class="header" href="#noqueuedconfig">NoQueuedConfig</a></h3>
<p>Error thrown when there is no queued configuration to commit.</p>
<pre><code class="language-solidity">error NoQueuedConfig();
</code></pre>
<h3 id="feeexceedsmaximum"><a class="header" href="#feeexceedsmaximum">FeeExceedsMaximum</a></h3>
<p>Error thrown when a fee exceeds the maximum allowed.</p>
<pre><code class="language-solidity">error FeeExceedsMaximum();
</code></pre>
<h3 id="delayperiodnotpassed"><a class="header" href="#delayperiodnotpassed">DelayPeriodNotPassed</a></h3>
<p>Error thrown when the delay period for new fees to take effect has not passed.</p>
<pre><code class="language-solidity">error DelayPeriodNotPassed();
</code></pre>
<h3 id="noqueueddelayperiod"><a class="header" href="#noqueueddelayperiod">NoQueuedDelayPeriod</a></h3>
<p>Error thrown when there is no queued delay period to commit.</p>
<pre><code class="language-solidity">error NoQueuedDelayPeriod();
</code></pre>
<h2 id="structs-2"><a class="header" href="#structs-2">Structs</a></h2>
<h3 id="protocolconfig-1"><a class="header" href="#protocolconfig-1">ProtocolConfig</a></h3>
<p>Configuration parameters for a specific protocol.</p>
<p><em>Contains both active and queued fee configurations with timestamps for delay mechanism.
Optimized for gas efficiency by packing fields into 3 storage slots instead of 6.
Active values are used for current operations, queued values become active after commitment.</em></p>
<pre><code class="language-solidity">struct ProtocolConfig {
    uint128 protocolFees;
    uint128 queuedProtocolFees;
    uint64 lastUpdated;
    uint64 queuedTimestamp;
    address feeReceiver;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accountant-2"><a class="header" href="#accountant-2">Accountant</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/Accountant.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
ReentrancyGuardTransient, Ownable2Step, <a href="src/Accountant.sol//src/interfaces/IAccountant.sol/interface.IAccountant.html">IAccountant</a></p>
<p>A comprehensive system for managing reward distribution and accounting across vaults and users.</p>
<p>*Implements a gas-optimized packed storage system for efficient reward tracking and distribution.
Key responsibilities:</p>
<ul>
<li>Tracks user balances and rewards across vaults.</li>
<li>Manages protocol fees and dynamic harvest fees.</li>
<li>Handles reward distribution and claiming.</li>
<li>Maintains integral calculations for reward accrual.*</li>
</ul>
<h2 id="state-variables-14"><a class="header" href="#state-variables-14">State Variables</a></h2>
<h3 id="scaling_factor"><a class="header" href="#scaling_factor">SCALING_FACTOR</a></h3>
<p>RAY scaling factor used for fixed-point arithmetic precision.</p>
<pre><code class="language-solidity">uint128 public constant SCALING_FACTOR = 1e27;
</code></pre>
<h3 id="max_fee_percent-1"><a class="header" href="#max_fee_percent-1">MAX_FEE_PERCENT</a></h3>
<p>The maximum fee percent (40%).</p>
<pre><code class="language-solidity">uint128 public constant MAX_FEE_PERCENT = 0.4e18;
</code></pre>
<h3 id="min_meaningful_rewards"><a class="header" href="#min_meaningful_rewards">MIN_MEANINGFUL_REWARDS</a></h3>
<p>The minimum amount of rewards to be added to the vault.</p>
<pre><code class="language-solidity">uint128 public constant MIN_MEANINGFUL_REWARDS = 1e18;
</code></pre>
<h3 id="protocol_controller-1"><a class="header" href="#protocol_controller-1">PROTOCOL_CONTROLLER</a></h3>
<p>The registry of addresses.</p>
<pre><code class="language-solidity">IProtocolController public immutable PROTOCOL_CONTROLLER;
</code></pre>
<h3 id="reward_token-2"><a class="header" href="#reward_token-2">REWARD_TOKEN</a></h3>
<p>The reward token.</p>
<pre><code class="language-solidity">address public immutable REWARD_TOKEN;
</code></pre>
<h3 id="protocol_id-1"><a class="header" href="#protocol_id-1">PROTOCOL_ID</a></h3>
<p>The protocol ID.</p>
<pre><code class="language-solidity">bytes4 public immutable PROTOCOL_ID;
</code></pre>
<h3 id="default_protocol_fee"><a class="header" href="#default_protocol_fee">DEFAULT_PROTOCOL_FEE</a></h3>
<p>The default protocol fee.</p>
<p><em>The validity of this value is not checked. It must always be valid</em></p>
<pre><code class="language-solidity">uint128 internal constant DEFAULT_PROTOCOL_FEE = 0.15e18;
</code></pre>
<h3 id="default_harvest_fee"><a class="header" href="#default_harvest_fee">DEFAULT_HARVEST_FEE</a></h3>
<p>The default harvest fee.</p>
<p><em>The validity of this value is not checked. It must always be valid</em></p>
<pre><code class="language-solidity">uint128 internal constant DEFAULT_HARVEST_FEE = 0.001e18;
</code></pre>
<h3 id="feesparams"><a class="header" href="#feesparams">feesParams</a></h3>
<p>The feesParams struct.</p>
<pre><code class="language-solidity">FeesParams public feesParams;
</code></pre>
<h3 id="protocolfeesaccrued"><a class="header" href="#protocolfeesaccrued">protocolFeesAccrued</a></h3>
<p>The total protocol fees collected but not yet claimed.</p>
<pre><code class="language-solidity">uint256 public protocolFeesAccrued;
</code></pre>
<h3 id="vaults-1"><a class="header" href="#vaults-1">vaults</a></h3>
<p>Supply of vaults.</p>
<p><em>Vault address -&gt; VaultData.</em></p>
<pre><code class="language-solidity">mapping(address vault =&gt; VaultData vaultData) internal vaults;
</code></pre>
<h3 id="accounts"><a class="header" href="#accounts">accounts</a></h3>
<p>Balances of accounts per vault.</p>
<p><em>Vault address -&gt; Account address -&gt; AccountData.</em></p>
<pre><code class="language-solidity">mapping(address vault =&gt; mapping(address account =&gt; AccountData accountData)) internal accounts;
</code></pre>
<h2 id="functions-30"><a class="header" href="#functions-30">Functions</a></h2>
<h3 id="onlyallowed"><a class="header" href="#onlyallowed">onlyAllowed</a></h3>
<pre><code class="language-solidity">modifier onlyAllowed();
</code></pre>
<h3 id="constructor-9"><a class="header" href="#constructor-9">constructor</a></h3>
<p>Initializes the Accountant contract with owner, registry, and reward token.</p>
<p><strong>Notes:</strong></p>
<ul>
<li>
<p>throws: OwnableInvalidOwner If the owner is the zero address.</p>
</li>
<li>
<p>throws: InvalidProtocolController If the protocol controller is the zero address.</p>
</li>
<li>
<p>throws: InvalidRewardToken If the reward token is the zero address.</p>
</li>
</ul>
<pre><code class="language-solidity">constructor(address _owner, address _registry, address _rewardToken, bytes4 _protocolId) Ownable(_owner);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_owner</code></td><td><code>address</code></td><td>The address of the contract owner.</td></tr>
<tr><td><code>_registry</code></td><td><code>address</code></td><td>The address of the registry contract.</td></tr>
<tr><td><code>_rewardToken</code></td><td><code>address</code></td><td>The address of the reward token.</td></tr>
<tr><td><code>_protocolId</code></td><td><code>bytes4</code></td><td>The bytes4 ID of the protocol</td></tr>
</tbody></table>
</div>
<h3 id="checkpoint-2"><a class="header" href="#checkpoint-2">checkpoint</a></h3>
<p>Checkpoints the state of the vault on every account action.</p>
<p>*Handles four types of operations with complex reward and balance management:</p>
<ol>
<li>Minting (from == address(0)):</li>
</ol>
<ul>
<li>Creates new tokens by increasing supply</li>
<li>Updates receiver's rewards based on current integral if receiver exists</li>
</ul>
<ol start="2">
<li>Burning (to == address(0)):</li>
</ol>
<ul>
<li>Destroys tokens by decreasing supply</li>
<li>Updates sender's rewards based on current integral</li>
</ul>
<ol start="3">
<li>Transfers:</li>
</ol>
<ul>
<li>Supply remains unchanged</li>
<li>Updates sender's rewards based on current integral and decreases balance</li>
<li>Updates receiver's rewards based on current integral and increases balance</li>
</ul>
<ol start="4">
<li>Reward Distribution: Processes pending rewards if they exist and supply &gt; 0
Two possible policies:
a) HARVEST policy [1]:</li>
</ol>
<ul>
<li>Charges only protocol fee on harvested rewards</li>
<li>Updates integral immediately</li>
<li>Protocol fees are accrued immediately
b) CHECKPOINT policy [0] (if newRewards &gt;= MIN_MEANINGFUL_REWARDS):</li>
<li>Charges both protocol and harvest fees</li>
<li>Updates integral</li>
<li>Fees are reserved rather than immediately accrued</li>
<li>Updates vault's total amounts and credited rewards
The function follows this execution flow:</li>
</ul>
<ol>
<li>First processes any pending rewards if they exist</li>
<li>Then handles the token operation (mint/burn/transfer)</li>
<li>Finally updates the vault's state*</li>
</ol>
<p><strong>Note:</strong>
throws: OnlyVault If caller is not the registered vault for the gauge.</p>
<pre><code class="language-solidity">function checkpoint(
    address gauge,
    address from,
    address to,
    uint128 amount,
    IStrategy.PendingRewards calldata pendingRewards,
    IStrategy.HarvestPolicy policy
) public nonReentrant;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The underlying gauge address of the vault.</td></tr>
<tr><td><code>from</code></td><td><code>address</code></td><td>The source address (address(0) for minting).</td></tr>
<tr><td><code>to</code></td><td><code>address</code></td><td>The destination address (address(0) for burning).</td></tr>
<tr><td><code>amount</code></td><td><code>uint128</code></td><td>The amount of tokens being transferred/minted/burned.</td></tr>
<tr><td><code>pendingRewards</code></td><td><code>IStrategy.PendingRewards</code></td><td>New rewards to be distributed to the vault.</td></tr>
<tr><td><code>policy</code></td><td><code>IStrategy.HarvestPolicy</code></td><td>The harvest policy to use.</td></tr>
</tbody></table>
</div>
<h3 id="checkpoint-3"><a class="header" href="#checkpoint-3">checkpoint</a></h3>
<p>Checkpoints the state of the vault on every account action.</p>
<p><em>This function is a wrapper of <code>checkpoint</code> that emits the <code>Referrer</code> event.</em></p>
<p><strong>Note:</strong>
throws: OnlyVault If caller is not the registered vault for the gauge.</p>
<pre><code class="language-solidity">function checkpoint(
    address gauge,
    address from,
    address to,
    uint128 amount,
    IStrategy.PendingRewards calldata pendingRewards,
    IStrategy.HarvestPolicy policy,
    address referrer
) external;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The underlying gauge address of the vault.</td></tr>
<tr><td><code>from</code></td><td><code>address</code></td><td>The source address (address(0) for minting).</td></tr>
<tr><td><code>to</code></td><td><code>address</code></td><td>The destination address (address(0) for burning).</td></tr>
<tr><td><code>amount</code></td><td><code>uint128</code></td><td>The amount of tokens being transferred/minted/burned.</td></tr>
<tr><td><code>pendingRewards</code></td><td><code>IStrategy.PendingRewards</code></td><td>New rewards to be distributed to the vault.</td></tr>
<tr><td><code>policy</code></td><td><code>IStrategy.HarvestPolicy</code></td><td>The harvest policy to use.</td></tr>
<tr><td><code>referrer</code></td><td><code>address</code></td><td>The address of the referrer.</td></tr>
</tbody></table>
</div>
<h3 id="_updateaccountstate"><a class="header" href="#_updateaccountstate">_updateAccountState</a></h3>
<p><em>Updates account state during operations.</em></p>
<pre><code class="language-solidity">function _updateAccountState(address vault, address account, uint128 amount, bool isDecrease, uint256 currentIntegral)
    private;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>vault</code></td><td><code>address</code></td><td>The vault address.</td></tr>
<tr><td><code>account</code></td><td><code>address</code></td><td>The account to update.</td></tr>
<tr><td><code>amount</code></td><td><code>uint128</code></td><td>The amount to add/subtract.</td></tr>
<tr><td><code>isDecrease</code></td><td><code>bool</code></td><td>Whether to decrease (true) or increase (false) the balance.</td></tr>
<tr><td><code>currentIntegral</code></td><td><code>uint256</code></td><td>The current reward integral to checkpoint against.</td></tr>
</tbody></table>
</div>
<h3 id="totalsupply-2"><a class="header" href="#totalsupply-2">totalSupply</a></h3>
<p>Returns the total supply of tokens in a vault.</p>
<pre><code class="language-solidity">function totalSupply(address vault) external view returns (uint128);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>vault</code></td><td><code>address</code></td><td>The vault address to query.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint128</code></td><td>_ The total supply of tokens in the vault.</td></tr>
</tbody></table>
</div>
<h3 id="balanceof-5"><a class="header" href="#balanceof-5">balanceOf</a></h3>
<p>Returns the token balance of an account in a vault.</p>
<pre><code class="language-solidity">function balanceOf(address vault, address account) external view returns (uint128);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>vault</code></td><td><code>address</code></td><td>The vault address to query.</td></tr>
<tr><td><code>account</code></td><td><code>address</code></td><td>The account address to check.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint128</code></td><td>_ The account's token balance in the vault.</td></tr>
</tbody></table>
</div>
<h3 id="getpendingrewards-2"><a class="header" href="#getpendingrewards-2">getPendingRewards</a></h3>
<p>Returns the pending rewards for an account in a vault.</p>
<pre><code class="language-solidity">function getPendingRewards(address vault, address account) external view returns (uint256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>vault</code></td><td><code>address</code></td><td>The vault address to query.</td></tr>
<tr><td><code>account</code></td><td><code>address</code></td><td>The account address to check.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>_ The pending rewards for the account in the vault.</td></tr>
</tbody></table>
</div>
<h3 id="getpendingrewards-3"><a class="header" href="#getpendingrewards-3">getPendingRewards</a></h3>
<p>Returns the pending rewards for a vault.</p>
<pre><code class="language-solidity">function getPendingRewards(address vault) external view returns (uint128);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>vault</code></td><td><code>address</code></td><td>The vault address to query.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint128</code></td><td>The pending rewards for the vault.</td></tr>
</tbody></table>
</div>
<h3 id="getvaultintegral"><a class="header" href="#getvaultintegral">getVaultIntegral</a></h3>
<p>Returns the integral for a vault.</p>
<pre><code class="language-solidity">function getVaultIntegral(address vault) external view returns (uint256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>vault</code></td><td><code>address</code></td><td>The vault address to query.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>The integral for the vault.</td></tr>
</tbody></table>
</div>
<h3 id="harvest-2"><a class="header" href="#harvest-2">harvest</a></h3>
<p>Harvests rewards from multiple gauges.</p>
<p><strong>Note:</strong>
throws: NoStrategy If the harvester is not set.</p>
<pre><code class="language-solidity">function harvest(address[] calldata _gauges, bytes[] calldata _harvestData, address _receiver) external;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_gauges</code></td><td><code>address[]</code></td><td>Array of gauges to harvest from.</td></tr>
<tr><td><code>_harvestData</code></td><td><code>bytes[]</code></td><td>Array of harvest data for each gauge.</td></tr>
<tr><td><code>_receiver</code></td><td><code>address</code></td><td>Address that will receive the harvester fee.</td></tr>
</tbody></table>
</div>
<h3 id="_harvest"><a class="header" href="#_harvest">_harvest</a></h3>
<p><em>Internal implementation of batch harvesting.</em></p>
<p>*This implementation optimizes gas by:</p>
<ol>
<li>Batching all harvests before calling flush() only once at the end</li>
<li>Collecting all rewards in a single transfer from the Strategy*</li>
</ol>
<pre><code class="language-solidity">function _harvest(address[] memory _gauges, bytes[] memory harvestData, address receiver) internal nonReentrant;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_gauges</code></td><td><code>address[]</code></td><td>Array of gauges to harvest from.</td></tr>
<tr><td><code>harvestData</code></td><td><code>bytes[]</code></td><td>Harvest data for each gauge.</td></tr>
<tr><td><code>receiver</code></td><td><code>address</code></td><td>Address that will receive the harvester fee.</td></tr>
</tbody></table>
</div>
<h3 id="getharvestfeepercent"><a class="header" href="#getharvestfeepercent">getHarvestFeePercent</a></h3>
<p>Returns the current harvest fee percentage.</p>
<pre><code class="language-solidity">function getHarvestFeePercent() public view returns (uint128);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint128</code></td><td>_ The harvest fee percentage.</td></tr>
</tbody></table>
</div>
<h3 id="setharvestfeepercent"><a class="header" href="#setharvestfeepercent">setHarvestFeePercent</a></h3>
<p>Updates the harvest fee percentage.</p>
<p><strong>Note:</strong>
throws: FeeExceedsMaximum If fee would exceed maximum.</p>
<pre><code class="language-solidity">function setHarvestFeePercent(uint128 newHarvestFeePercent) external onlyOwner;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>newHarvestFeePercent</code></td><td><code>uint128</code></td><td>New harvest fee percentage (scaled by 1e18).</td></tr>
</tbody></table>
</div>
<h3 id="claim-9"><a class="header" href="#claim-9">claim</a></h3>
<p>Claims multiple vault rewards for yourself.</p>
<p><strong>Note:</strong>
throws: NoPendingRewards If there are no rewards to claim.</p>
<pre><code class="language-solidity">function claim(address[] calldata _gauges, bytes[] calldata harvestData) external;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_gauges</code></td><td><code>address[]</code></td><td>Array of gauges to claim rewards from.</td></tr>
<tr><td><code>harvestData</code></td><td><code>bytes[]</code></td><td>Optional harvest data for each gauge. Empty bytes for gauges that don't need harvesting.</td></tr>
</tbody></table>
</div>
<h3 id="claim-10"><a class="header" href="#claim-10">claim</a></h3>
<p>Claims multiple vault rewards for yourself and sends them to a specific address.</p>
<p><strong>Note:</strong>
throws: NoPendingRewards If there are no rewards to claim.</p>
<pre><code class="language-solidity">function claim(address[] calldata _gauges, bytes[] calldata harvestData, address receiver) public;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_gauges</code></td><td><code>address[]</code></td><td>Array of gauges to claim rewards from.</td></tr>
<tr><td><code>harvestData</code></td><td><code>bytes[]</code></td><td>Optional harvest data for each gauge. Empty bytes for gauges that don't need harvesting.</td></tr>
<tr><td><code>receiver</code></td><td><code>address</code></td><td>Address that will receive the claimed rewards.</td></tr>
</tbody></table>
</div>
<h3 id="claim-11"><a class="header" href="#claim-11">claim</a></h3>
<p>Claims multiple vault rewards on behalf of an account.</p>
<p><em>expected to be called by authorized accounts only</em></p>
<p><strong>Notes:</strong></p>
<ul>
<li>
<p>throws: OnlyAllowed If caller is not allowed to claim on behalf of others.</p>
</li>
<li>
<p>throws: NoPendingRewards If there are no rewards to claim.</p>
</li>
</ul>
<pre><code class="language-solidity">function claim(address[] calldata _gauges, address account, bytes[] calldata harvestData) external;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_gauges</code></td><td><code>address[]</code></td><td>Array of gauges to claim rewards from.</td></tr>
<tr><td><code>account</code></td><td><code>address</code></td><td>Address to claim rewards for.</td></tr>
<tr><td><code>harvestData</code></td><td><code>bytes[]</code></td><td>Optional harvest data for each gauge. Empty bytes for gauges that don't need harvesting.</td></tr>
</tbody></table>
</div>
<h3 id="claim-12"><a class="header" href="#claim-12">claim</a></h3>
<p>Claims multiple vault rewards on behalf of an account and sends them to a specific address.</p>
<p><em>expected to be called by authorized accounts only</em></p>
<p><strong>Notes:</strong></p>
<ul>
<li>
<p>throws: OnlyAllowed If caller is not allowed to claim on behalf of others.</p>
</li>
<li>
<p>throws: NoPendingRewards If there are no rewards to claim.</p>
</li>
</ul>
<pre><code class="language-solidity">function claim(address[] calldata _gauges, address account, bytes[] calldata harvestData, address receiver)
    public
    onlyAllowed;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_gauges</code></td><td><code>address[]</code></td><td>Array of gauges to claim rewards from.</td></tr>
<tr><td><code>account</code></td><td><code>address</code></td><td>Address to claim rewards for.</td></tr>
<tr><td><code>harvestData</code></td><td><code>bytes[]</code></td><td>Optional harvest data for each gauge. Empty bytes for gauges that don't need harvesting.</td></tr>
<tr><td><code>receiver</code></td><td><code>address</code></td><td>Address that will receive the claimed rewards.</td></tr>
</tbody></table>
</div>
<h3 id="_claim-1"><a class="header" href="#_claim-1">_claim</a></h3>
<p><em>Internal implementation of claim functionality.</em></p>
<p><strong>Note:</strong>
throws: NoPendingRewards If the total claimed amount is zero.</p>
<pre><code class="language-solidity">function _claim(address[] calldata _gauges, address account, address receiver) internal nonReentrant;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_gauges</code></td><td><code>address[]</code></td><td>Array of gauges to claim rewards from.</td></tr>
<tr><td><code>account</code></td><td><code>address</code></td><td>Address to claim rewards for.</td></tr>
<tr><td><code>receiver</code></td><td><code>address</code></td><td>Address that will receive the claimed rewards.</td></tr>
</tbody></table>
</div>
<h3 id="getprotocolfeepercent"><a class="header" href="#getprotocolfeepercent">getProtocolFeePercent</a></h3>
<p>Returns the current protocol fee percentage.</p>
<pre><code class="language-solidity">function getProtocolFeePercent() public view returns (uint128);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint128</code></td><td>_ The protocol fee percentage.</td></tr>
</tbody></table>
</div>
<h3 id="setprotocolfeepercent"><a class="header" href="#setprotocolfeepercent">setProtocolFeePercent</a></h3>
<p>Updates the protocol fee percentage.</p>
<p><strong>Note:</strong>
throws: FeeExceedsMaximum If fee would exceed maximum.</p>
<pre><code class="language-solidity">function setProtocolFeePercent(uint128 newProtocolFeePercent) external onlyOwner;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>newProtocolFeePercent</code></td><td><code>uint128</code></td><td>New protocol fee percentage (scaled by 1e18).</td></tr>
</tbody></table>
</div>
<h3 id="claimprotocolfees-1"><a class="header" href="#claimprotocolfees-1">claimProtocolFees</a></h3>
<p>Claims accumulated protocol fees.</p>
<p><em>Transfers fees to the configured fee receiver.</em></p>
<p><strong>Note:</strong>
throws: NoFeeReceiver If the fee receiver is not set.</p>
<pre><code class="language-solidity">function claimProtocolFees() external nonReentrant;
</code></pre>
<h3 id="gettotalfeepercent"><a class="header" href="#gettotalfeepercent">getTotalFeePercent</a></h3>
<p>Returns the total fee percentage (protocol + harvest).</p>
<pre><code class="language-solidity">function getTotalFeePercent() external view returns (uint128);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint128</code></td><td>_ The total fee percentage.</td></tr>
</tbody></table>
</div>
<h2 id="events-2"><a class="header" href="#events-2">Events</a></h2>
<h3 id="protocolfeesclaimed"><a class="header" href="#protocolfeesclaimed">ProtocolFeesClaimed</a></h3>
<p>Emitted when protocol fees are claimed.</p>
<pre><code class="language-solidity">event ProtocolFeesClaimed(uint256 amount);
</code></pre>
<h3 id="harvest-3"><a class="header" href="#harvest-3">Harvest</a></h3>
<p>Emitted when a vault harvests rewards.</p>
<pre><code class="language-solidity">event Harvest(
    address indexed vault, uint256 integral, uint256 supply, uint256 amount, uint256 protocolFee, uint256 harvesterFee
);
</code></pre>
<h3 id="checkpoint-4"><a class="header" href="#checkpoint-4">Checkpoint</a></h3>
<p>Emitted when a checkpoint is made.</p>
<pre><code class="language-solidity">event Checkpoint(
    address indexed vault,
    address indexed from,
    address indexed to,
    uint128 amount,
    uint256 integral,
    uint256 supply,
    IStrategy.HarvestPolicy policy
);
</code></pre>
<h3 id="accountcheckpoint"><a class="header" href="#accountcheckpoint">AccountCheckpoint</a></h3>
<p>Emitted when an account checkpoint is made.</p>
<pre><code class="language-solidity">event AccountCheckpoint(
    address indexed vault, address indexed account, uint128 balance, uint256 integral, uint256 pendingRewards
);
</code></pre>
<h3 id="rewardsclaimed"><a class="header" href="#rewardsclaimed">RewardsClaimed</a></h3>
<p>Emitted when a user claims rewards.</p>
<pre><code class="language-solidity">event RewardsClaimed(address indexed vault, address indexed account, address receiver, uint256 amount);
</code></pre>
<h3 id="protocolfeepercentset"><a class="header" href="#protocolfeepercentset">ProtocolFeePercentSet</a></h3>
<p>Emitted when the protocol fee percent is updated.</p>
<pre><code class="language-solidity">event ProtocolFeePercentSet(uint128 oldProtocolFeePercent, uint128 newProtocolFeePercent);
</code></pre>
<h3 id="harvestfeepercentset"><a class="header" href="#harvestfeepercentset">HarvestFeePercentSet</a></h3>
<p>Emitted when the harvest fee percent is updated.</p>
<pre><code class="language-solidity">event HarvestFeePercentSet(uint128 oldHarvestFeePercent, uint128 newHarvestFeePercent);
</code></pre>
<h3 id="referrer"><a class="header" href="#referrer">Referrer</a></h3>
<p>Emitted when a deposit is made via a referrer</p>
<pre><code class="language-solidity">event Referrer(address indexed referrer, address referree, uint128 assets);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>referrer</code></td><td><code>address</code></td><td>The address of the referrer</td></tr>
<tr><td><code>referree</code></td><td><code>address</code></td><td>The address of the referree (the address that receives the shares)</td></tr>
<tr><td><code>assets</code></td><td><code>uint128</code></td><td>The amount of assets deposited (1:1 with shares)</td></tr>
</tbody></table>
</div>
<h2 id="errors-7"><a class="header" href="#errors-7">Errors</a></h2>
<h3 id="onlyvault"><a class="header" href="#onlyvault">OnlyVault</a></h3>
<p>Error thrown when the caller is not a vault.</p>
<pre><code class="language-solidity">error OnlyVault();
</code></pre>
<h3 id="onlyallowed-1"><a class="header" href="#onlyallowed-1">OnlyAllowed</a></h3>
<p>Error thrown when the caller is not allowed.</p>
<pre><code class="language-solidity">error OnlyAllowed();
</code></pre>
<h3 id="nostrategy"><a class="header" href="#nostrategy">NoStrategy</a></h3>
<p>Error thrown when the strategy is not set.</p>
<pre><code class="language-solidity">error NoStrategy();
</code></pre>
<h3 id="nofeereceiver"><a class="header" href="#nofeereceiver">NoFeeReceiver</a></h3>
<p>Error thrown when the fee receiver is not set.</p>
<pre><code class="language-solidity">error NoFeeReceiver();
</code></pre>
<h3 id="nopendingrewards"><a class="header" href="#nopendingrewards">NoPendingRewards</a></h3>
<p>Error thrown when there are no pending rewards.</p>
<pre><code class="language-solidity">error NoPendingRewards();
</code></pre>
<h3 id="insufficientpendingrewards"><a class="header" href="#insufficientpendingrewards">InsufficientPendingRewards</a></h3>
<p>Error thrown when the pending rewards are not enough.</p>
<pre><code class="language-solidity">error InsufficientPendingRewards();
</code></pre>
<h3 id="netcreditsnotenough"><a class="header" href="#netcreditsnotenough">NetCreditsNotEnough</a></h3>
<p>Error thrown when the net credits are not enough.</p>
<pre><code class="language-solidity">error NetCreditsNotEnough();
</code></pre>
<h3 id="feesexceedrewards"><a class="header" href="#feesexceedrewards">FeesExceedRewards</a></h3>
<p>Error thrown when the fees exceed the rewards.</p>
<pre><code class="language-solidity">error FeesExceedRewards();
</code></pre>
<h3 id="feeexceedsmaximum-1"><a class="header" href="#feeexceedsmaximum-1">FeeExceedsMaximum</a></h3>
<p>Error thrown when a fee exceeds the maximum allowed</p>
<pre><code class="language-solidity">error FeeExceedsMaximum();
</code></pre>
<h3 id="invalidvault"><a class="header" href="#invalidvault">InvalidVault</a></h3>
<p>Error thrown when the vault is invalid</p>
<pre><code class="language-solidity">error InvalidVault();
</code></pre>
<h3 id="invalidharvestdatalength"><a class="header" href="#invalidharvestdatalength">InvalidHarvestDataLength</a></h3>
<p>Error thrown when harvest data length doesn't match vaults length</p>
<pre><code class="language-solidity">error InvalidHarvestDataLength();
</code></pre>
<h3 id="invalidprotocolcontroller"><a class="header" href="#invalidprotocolcontroller">InvalidProtocolController</a></h3>
<p>Error thrown when the protocol controller is invalid</p>
<pre><code class="language-solidity">error InvalidProtocolController();
</code></pre>
<h3 id="invalidrewardtoken"><a class="header" href="#invalidrewardtoken">InvalidRewardToken</a></h3>
<p>Error thrown when the reward token is invalid</p>
<pre><code class="language-solidity">error InvalidRewardToken();
</code></pre>
<h3 id="invalidprotocolid"><a class="header" href="#invalidprotocolid">InvalidProtocolId</a></h3>
<p>Error thrown when the protocol ID is invalid</p>
<pre><code class="language-solidity">error InvalidProtocolId();
</code></pre>
<h3 id="harvesttokennotreceived"><a class="header" href="#harvesttokennotreceived">HarvestTokenNotReceived</a></h3>
<p>Error thrown when the harvester has not transferred the correct amount of tokens to the Accountant contract</p>
<pre><code class="language-solidity">error HarvestTokenNotReceived();
</code></pre>
<h2 id="structs-3"><a class="header" href="#structs-3">Structs</a></h2>
<h3 id="vaultdata"><a class="header" href="#vaultdata">VaultData</a></h3>
<p>Vault data structure.</p>
<pre><code class="language-solidity">struct VaultData {
    uint256 integral;
    uint128 supply;
    uint128 feeSubjectAmount;
    uint128 totalAmount;
    uint128 netCredited;
    uint128 reservedHarvestFee;
    uint128 reservedProtocolFee;
}
</code></pre>
<h3 id="accountdata"><a class="header" href="#accountdata">AccountData</a></h3>
<p>Account data structure for a specific Vault</p>
<pre><code class="language-solidity">struct AccountData {
    uint128 balance;
    uint256 integral;
    uint256 pendingRewards;
}
</code></pre>
<h3 id="feesparams-1"><a class="header" href="#feesparams-1">FeesParams</a></h3>
<p>Struct that defines the fees parameters.</p>
<pre><code class="language-solidity">struct FeesParams {
    uint128 protocolFeePercent;
    uint128 harvestFeePercent;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="allocator-1"><a class="header" href="#allocator-1">Allocator</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/Allocator.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
<a href="src/Allocator.sol//src/interfaces/IAllocator.sol/interface.IAllocator.html">IAllocator</a></p>
<p><strong>Author:</strong>
Stake DAO</p>
<p>Handles optimal distribution of deposited funds across multiple yield strategies</p>
<p><em>This is a base contract that implements the IAllocator interface. It provides a simple
allocation strategy that directs all funds to a single gateway. More complex allocation
strategies can be implemented by inheriting from this contract and overriding the allocation
functions.</em></p>
<h2 id="state-variables-15"><a class="header" href="#state-variables-15">State Variables</a></h2>
<h3 id="locker-1"><a class="header" href="#locker-1">LOCKER</a></h3>
<p>The address of the locker contract</p>
<p><em>This is the contract that holds tokens for staking.</em></p>
<pre><code class="language-solidity">address public immutable LOCKER;
</code></pre>
<h3 id="gateway-1"><a class="header" href="#gateway-1">GATEWAY</a></h3>
<p>The address of the gateway contract</p>
<p><em>This is the contract that handles the actual deposit/withdrawal operations.</em></p>
<pre><code class="language-solidity">address public immutable GATEWAY;
</code></pre>
<h2 id="functions-31"><a class="header" href="#functions-31">Functions</a></h2>
<h3 id="constructor-10"><a class="header" href="#constructor-10">constructor</a></h3>
<p>Initializes the Allocator contract</p>
<p><em>If _locker is address(0), LOCKER will be set to the same address as GATEWAY</em></p>
<pre><code class="language-solidity">constructor(address _locker, address _gateway);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_locker</code></td><td><code>address</code></td><td>The address of the locker contract (can be address(0) for L2s)</td></tr>
<tr><td><code>_gateway</code></td><td><code>address</code></td><td>The address of the gateway contract</td></tr>
</tbody></table>
</div>
<h3 id="getdepositallocation-2"><a class="header" href="#getdepositallocation-2">getDepositAllocation</a></h3>
<p>Determines how funds should be allocated during a deposit</p>
<p><em>In this base implementation, all funds are directed to the LOCKER</em></p>
<pre><code class="language-solidity">function getDepositAllocation(address asset, address gauge, uint256 amount)
    public
    view
    virtual
    returns (Allocation memory);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>asset</code></td><td><code>address</code></td><td>The address of the asset contract</td></tr>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The address of the gauge contract</td></tr>
<tr><td><code>amount</code></td><td><code>uint256</code></td><td>The amount of tokens to deposit</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Allocation</code></td><td>Allocation struct containing the allocation details</td></tr>
</tbody></table>
</div>
<h3 id="getwithdrawalallocation-2"><a class="header" href="#getwithdrawalallocation-2">getWithdrawalAllocation</a></h3>
<p>Determines how funds should be allocated during a withdrawal</p>
<p><em>In this base implementation, all funds are withdrawn from the LOCKER</em></p>
<pre><code class="language-solidity">function getWithdrawalAllocation(address asset, address gauge, uint256 amount)
    public
    view
    virtual
    returns (Allocation memory);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>asset</code></td><td><code>address</code></td><td></td></tr>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The address of the gauge contract</td></tr>
<tr><td><code>amount</code></td><td><code>uint256</code></td><td>The amount of tokens to withdraw</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Allocation</code></td><td>Allocation struct containing the allocation details</td></tr>
</tbody></table>
</div>
<h3 id="getrebalancedallocation-2"><a class="header" href="#getrebalancedallocation-2">getRebalancedAllocation</a></h3>
<p>Determines how funds should be allocated during a rebalance</p>
<p><em>In this base implementation, rebalancing uses the same allocation as deposits</em></p>
<pre><code class="language-solidity">function getRebalancedAllocation(address asset, address gauge, uint256 amount)
    public
    view
    virtual
    returns (Allocation memory);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>asset</code></td><td><code>address</code></td><td></td></tr>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The address of the gauge contract</td></tr>
<tr><td><code>amount</code></td><td><code>uint256</code></td><td>The amount of tokens to rebalance</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>Allocation</code></td><td>Allocation struct containing the allocation details</td></tr>
</tbody></table>
</div>
<h3 id="getallocationtargets-2"><a class="header" href="#getallocationtargets-2">getAllocationTargets</a></h3>
<p>Returns the list of target addresses for a specific gauge
gauge The address of the gauge contract (unused in this implementation)</p>
<p><em>In this base implementation, the only target is the LOCKER</em></p>
<pre><code class="language-solidity">function getAllocationTargets(address) public view virtual returns (address[] memory);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>address[]</code></td><td>An array containing the target addresses</td></tr>
</tbody></table>
</div>
<h2 id="errors-8"><a class="header" href="#errors-8">Errors</a></h2>
<h3 id="gatewayzeroaddress"><a class="header" href="#gatewayzeroaddress">GatewayZeroAddress</a></h3>
<p>Error thrown when the gateway is zero address</p>
<pre><code class="language-solidity">error GatewayZeroAddress();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="autocompoundedvault"><a class="header" href="#autocompoundedvault">AutocompoundedVault</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/AutocompoundedVault.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
ERC4626, Ownable2Step</p>
<p>This contract is a fully compliant ERC4626 streaming yield-bearing vault.
The rewards are streamed linearly over a fixed period and the vault is autocompounded.</p>
<p>*Streaming Reward Policy:</p>
<ul>
<li>If a new stream is started before the previous one ends, any unvested rewards from the previous stream
are automatically rolled over and added to the new stream amount. The combined total is then streamed
linearly over the new period.</li>
<li>This mechanism results in a &quot;premium&quot; for users present at the time of the new stream, as the remaining
rewards from the previous stream will vest more quickly than originally scheduled.</li>
<li>For optimal and fair reward distribution, it is strongly recommended to start a new stream only after
the previous stream has ended, or as close as possible to its scheduled end time. Starting new streams
prematurely can lead to accelerated vesting and may distort the intended reward schedule.</li>
<li>This design is a trade-off for simplicity and to keep the reward calendar predictable and aligned.*</li>
</ul>
<p><em>Direct Transfer Handling:
Any tokens sent directly to this contract (not via the setRewards function)
will be considered immediately vested and available to users. This means that accidental or
intentional direct transfers will increase the value returned by totalAssets() and can be
claimed by holders. This is an intentional design choice and should be considered
when integrating with or interacting with this vault.</em></p>
<p>*ERC4626 Virtual Shares/Assets Protection:
This contract inherits from OpenZeppelin's v5 ERC4626, which implements the &quot;virtual shares/assets&quot; protection mechanism.
This mechanism applies a +1 virtual offset to both totalSupply and totalAssets in the share/asset conversion formulas:</p>
<ul>
<li>shares = assets * (totalSupply() + 1) / (totalAssets() + 1)</li>
<li>assets = shares * (totalAssets() + 1) / (totalSupply() + 1)
This contract uses a decimal offset set to 0, which is the OpenZeppelin default.
With this configuration, the protection ensures that donation/inflation attacks are unprofitable.
Even with a decimal offset of 0, the attacker's loss is at least equal to the user's deposit, as documented by OpenZeppelin.*</li>
</ul>
<h2 id="state-variables-16"><a class="header" href="#state-variables-16">State Variables</a></h2>
<h3 id="streaming_period"><a class="header" href="#streaming_period">STREAMING_PERIOD</a></h3>
<p>--- CONSTANTS</p>
<p>The streaming period</p>
<pre><code class="language-solidity">uint128 public immutable STREAMING_PERIOD;
</code></pre>
<h3 id="currentstream"><a class="header" href="#currentstream">currentStream</a></h3>
<p>The current active stream</p>
<pre><code class="language-solidity">Stream internal currentStream;
</code></pre>
<h2 id="functions-32"><a class="header" href="#functions-32">Functions</a></h2>
<h3 id="constructor-11"><a class="header" href="#constructor-11">constructor</a></h3>
<p>Initialize the asset and the shares token</p>
<pre><code class="language-solidity">constructor(uint128 streamingPeriod, IERC20 asset, string memory shareName, string memory shareSymbol, address owner)
    ERC4626(asset)
    ERC20(shareName, shareSymbol)
    Ownable(owner);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>streamingPeriod</code></td><td><code>uint128</code></td><td>The streaming period in seconds (e.g. 7 days)</td></tr>
<tr><td><code>asset</code></td><td><code>IERC20</code></td><td>The asset token the users will deposit to the vault (e.g. sdYND)</td></tr>
<tr><td><code>shareName</code></td><td><code>string</code></td><td>The name of the shares token the users will receive</td></tr>
<tr><td><code>shareSymbol</code></td><td><code>string</code></td><td>The symbol of the shares token the users will receive</td></tr>
<tr><td><code>owner</code></td><td><code>address</code></td><td>The owner of the vault</td></tr>
</tbody></table>
</div>
<h3 id="totalassets"><a class="header" href="#totalassets">totalAssets</a></h3>
<p>--- OVERRIDED PUBLIC FUNCTIONS</p>
<p>Returns the total vested (usable) assets in the vault</p>
<p>*This function returns the actual usable balance of the asset token that can be used for share calculations.
It subtracts unvested rewards from the vault's total balance:</p>
<ul>
<li>If there is no active stream, or if the current stream has ended (timestamp &gt;= streamEnd),
returns the vault's full token balance</li>
<li>If there is an active stream, subtracts the unvested portion of the stream from the vault's balance.
The unvested portion is calculated linearly based on the remaining time in the stream*</li>
</ul>
<pre><code class="language-solidity">function totalAssets() public view virtual override returns (uint256);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>The total amount of vested asset token that are available for share calculations. This is the value used by the ERC4626 implementation for deposit/withdrawal calculations</td></tr>
</tbody></table>
</div>
<h3 id="setrewards"><a class="header" href="#setrewards">setRewards</a></h3>
<p>--- PUBLIC FUNCTIONS</p>
<p>Streams new rewards to the contract</p>
<p><em>Starting a new stream will add the unvested portion of the previous stream to the new stream
and the new stream will be for <code>STREAMING_PERIOD</code>. See the comments in the contract description for more details.</em></p>
<p><strong>Note:</strong>
throws: OwnableUnauthorizedAccount when the caller is not the owner</p>
<pre><code class="language-solidity">function setRewards(uint256 newAmount) external virtual onlyOwner;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>newAmount</code></td><td><code>uint256</code></td><td>The amount of asset tokens to stream</td></tr>
</tbody></table>
</div>
<h3 id="getcurrentstream"><a class="header" href="#getcurrentstream">getCurrentStream</a></h3>
<p>Returns the current stream data</p>
<pre><code class="language-solidity">function getCurrentStream()
    external
    view
    virtual
    returns (uint256 amount, uint256 remainingToken, uint128 start, uint128 end, uint128 remainingTime);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>amount</code></td><td><code>uint256</code></td><td>The amount of asset tokens streamed over the streaming period</td></tr>
<tr><td><code>remainingToken</code></td><td><code>uint256</code></td><td>The amount of asset tokens remaining to be streamed</td></tr>
<tr><td><code>start</code></td><td><code>uint128</code></td><td>The start timestamp of the stream</td></tr>
<tr><td><code>end</code></td><td><code>uint128</code></td><td>The end timestamp of the stream</td></tr>
<tr><td><code>remainingTime</code></td><td><code>uint128</code></td><td>The remaining time in the stream (in seconds)</td></tr>
</tbody></table>
</div>
<h3 id="_timestamp"><a class="header" href="#_timestamp">_timestamp</a></h3>
<p>--- INTERNAL FUNCTIONS</p>
<p>Returns the current timestamp casted to a uint128</p>
<p><em>Considering the maximum timestamp is <code>2^128 - 1</code>, casting is safe here
no need of using the <code>SafeCast</code> library</em></p>
<pre><code class="language-solidity">function _timestamp() internal view returns (uint128);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint128</code></td><td>The current timestamp casted to a uint128</td></tr>
</tbody></table>
</div>
<h3 id="version-8"><a class="header" href="#version-8">version</a></h3>
<p>Get the version of the contract</p>
<pre><code class="language-solidity">function version() external pure virtual returns (string memory);
</code></pre>
<h2 id="events-3"><a class="header" href="#events-3">Events</a></h2>
<h3 id="newstreamrewards"><a class="header" href="#newstreamrewards">NewStreamRewards</a></h3>
<p>--- EVENTS &amp; ERRORS</p>
<p>Event emitted when a new stream is started</p>
<pre><code class="language-solidity">event NewStreamRewards(address indexed caller, uint256 amount, uint128 start, uint128 end);
</code></pre>
<h2 id="structs-4"><a class="header" href="#structs-4">Structs</a></h2>
<h3 id="stream"><a class="header" href="#stream">Stream</a></h3>
<p>--- STATE</p>
<p>The struct holding the stream data</p>
<p><em>This struct takes 2 storage slots</em></p>
<pre><code class="language-solidity">struct Stream {
    uint256 amount;
    uint128 start;
    uint128 end;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="factory"><a class="header" href="#factory">Factory</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/Factory.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
<a href="src/Factory.sol//src/ProtocolContext.sol/contract.ProtocolContext.html">ProtocolContext</a></p>
<p>A base contract for implementing protocol-specific vault factories</p>
<p>*Provides core functionality for creating and managing vaults across different protocols
Key responsibilities:</p>
<ul>
<li>Deploys vaults and reward receivers for protocol gauges</li>
<li>Validates gauges and tokens</li>
<li>Registers vaults with the protocol controller</li>
<li>Sets up reward tokens for vaults*</li>
</ul>
<h2 id="state-variables-17"><a class="header" href="#state-variables-17">State Variables</a></h2>
<h3 id="reward_vault_implementation"><a class="header" href="#reward_vault_implementation">REWARD_VAULT_IMPLEMENTATION</a></h3>
<p>Reward vault implementation address</p>
<p><em>The implementation contract that will be cloned for each new vault</em></p>
<pre><code class="language-solidity">address public immutable REWARD_VAULT_IMPLEMENTATION;
</code></pre>
<h3 id="reward_receiver_implementation"><a class="header" href="#reward_receiver_implementation">REWARD_RECEIVER_IMPLEMENTATION</a></h3>
<p>Reward receiver implementation address</p>
<p><em>The implementation contract that will be cloned for each new reward receiver</em></p>
<pre><code class="language-solidity">address public immutable REWARD_RECEIVER_IMPLEMENTATION;
</code></pre>
<h2 id="functions-33"><a class="header" href="#functions-33">Functions</a></h2>
<h3 id="constructor-12"><a class="header" href="#constructor-12">constructor</a></h3>
<p>Initializes the factory with protocol controller, reward token, and vault implementation</p>
<pre><code class="language-solidity">constructor(
    address _protocolController,
    address _vaultImplementation,
    address _rewardReceiverImplementation,
    bytes4 _protocolId,
    address _locker,
    address _gateway
) ProtocolContext(_protocolId, _protocolController, _locker, _gateway);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_protocolController</code></td><td><code>address</code></td><td>Address of the protocol controller</td></tr>
<tr><td><code>_vaultImplementation</code></td><td><code>address</code></td><td>Address of the reward vault implementation</td></tr>
<tr><td><code>_rewardReceiverImplementation</code></td><td><code>address</code></td><td>Address of the reward receiver implementation</td></tr>
<tr><td><code>_protocolId</code></td><td><code>bytes4</code></td><td>Protocol identifier</td></tr>
<tr><td><code>_locker</code></td><td><code>address</code></td><td>Address of the locker</td></tr>
<tr><td><code>_gateway</code></td><td><code>address</code></td><td>Address of the gateway</td></tr>
</tbody></table>
</div>
<h3 id="createvault"><a class="header" href="#createvault">createVault</a></h3>
<p>Create a new vault for a given gauge</p>
<p><em>Deploys a vault and reward receiver for the gauge, registers them, and sets up reward tokens</em></p>
<p><strong>Notes:</strong></p>
<ul>
<li>
<p>throws: InvalidGauge If the gauge is not valid</p>
</li>
<li>
<p>throws: InvalidDeployment If the deployment is not valid</p>
</li>
<li>
<p>throws: GaugeAlreadyUsed If the gauge has already been used</p>
</li>
</ul>
<pre><code class="language-solidity">function createVault(address gauge) public virtual returns (address vault, address rewardReceiver);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>Address of the gauge</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>vault</code></td><td><code>address</code></td><td>Address of the deployed vault</td></tr>
<tr><td><code>rewardReceiver</code></td><td><code>address</code></td><td>Address of the deployed reward receiver</td></tr>
</tbody></table>
</div>
<h3 id="syncrewardtokens"><a class="header" href="#syncrewardtokens">syncRewardTokens</a></h3>
<p>Sync reward tokens for a gauge</p>
<p><em>Updates the reward tokens for an existing vault</em></p>
<p><strong>Note:</strong>
throws: InvalidGauge If the gauge is not valid or has no associated vault</p>
<pre><code class="language-solidity">function syncRewardTokens(address gauge) external;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>Address of the gauge</td></tr>
</tbody></table>
</div>
<h3 id="_getasset-1"><a class="header" href="#_getasset-1">_getAsset</a></h3>
<p>Get the asset address from a gauge</p>
<p><em>Must be implemented by derived factories to handle protocol-specific asset retrieval</em></p>
<pre><code class="language-solidity">function _getAsset(address gauge) internal view virtual returns (address);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>Address of the gauge</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>address</code></td><td>The address of the asset associated with the gauge</td></tr>
</tbody></table>
</div>
<h3 id="_isvaliddeployment-1"><a class="header" href="#_isvaliddeployment-1">_isValidDeployment</a></h3>
<p>Check if a deployment is valid</p>
<p><em>Can be overridden by derived factories to add additional deployment validation</em></p>
<pre><code class="language-solidity">function _isValidDeployment(address) internal view virtual returns (bool);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>bool</code></td><td>True if the deployment is valid, false otherwise</td></tr>
</tbody></table>
</div>
<h3 id="_initializevault-1"><a class="header" href="#_initializevault-1">_initializeVault</a></h3>
<p>Initialize the vault</p>
<pre><code class="language-solidity">function _initializeVault(address vault, address asset, address gauge) internal virtual;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>vault</code></td><td><code>address</code></td><td>Address of the vault</td></tr>
<tr><td><code>asset</code></td><td><code>address</code></td><td>Address of the asset</td></tr>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>Address of the gauge</td></tr>
</tbody></table>
</div>
<h3 id="_registervault"><a class="header" href="#_registervault">_registerVault</a></h3>
<p>Register the vault in the protocol controller</p>
<pre><code class="language-solidity">function _registerVault(address gauge, address vault, address asset, address rewardReceiver) internal;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>Address of the gauge</td></tr>
<tr><td><code>vault</code></td><td><code>address</code></td><td>Address of the vault</td></tr>
<tr><td><code>asset</code></td><td><code>address</code></td><td>Address of the asset</td></tr>
<tr><td><code>rewardReceiver</code></td><td><code>address</code></td><td>Address of the reward receiver</td></tr>
</tbody></table>
</div>
<h3 id="_setuprewardtokens-1"><a class="header" href="#_setuprewardtokens-1">_setupRewardTokens</a></h3>
<p>Setup reward tokens for the vault</p>
<p><em>Must be implemented by derived factories to handle protocol-specific reward token setup</em></p>
<pre><code class="language-solidity">function _setupRewardTokens(address vault, address gauge, address rewardReceiver) internal virtual;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>vault</code></td><td><code>address</code></td><td>Address of the vault</td></tr>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>Address of the gauge</td></tr>
<tr><td><code>rewardReceiver</code></td><td><code>address</code></td><td>Address of the reward receiver</td></tr>
</tbody></table>
</div>
<h3 id="_setrewardreceiver-1"><a class="header" href="#_setrewardreceiver-1">_setRewardReceiver</a></h3>
<p>Set the reward receiver for a gauge</p>
<p><em>Must be implemented by derived factories to handle protocol-specific reward receiver setup</em></p>
<pre><code class="language-solidity">function _setRewardReceiver(address gauge, address rewardReceiver) internal virtual;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>Address of the gauge</td></tr>
<tr><td><code>rewardReceiver</code></td><td><code>address</code></td><td>Address of the reward receiver</td></tr>
</tbody></table>
</div>
<h3 id="_isvalidgauge-2"><a class="header" href="#_isvalidgauge-2">_isValidGauge</a></h3>
<p>Check if a gauge is valid</p>
<p><em>Must be implemented by derived factories to handle protocol-specific gauge validation</em></p>
<pre><code class="language-solidity">function _isValidGauge(address gauge) internal view virtual returns (bool);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>Address of the gauge</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>bool</code></td><td>isValid True if the gauge is valid</td></tr>
</tbody></table>
</div>
<h3 id="_isvalidtoken-1"><a class="header" href="#_isvalidtoken-1">_isValidToken</a></h3>
<p>Check if a token is valid as a reward token</p>
<p><em>Validates that the token is not zero address and not the main reward token</em></p>
<pre><code class="language-solidity">function _isValidToken(address token) internal view virtual returns (bool);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>token</code></td><td><code>address</code></td><td>Address of the token</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>bool</code></td><td>isValid True if the token is valid</td></tr>
</tbody></table>
</div>
<h2 id="events-4"><a class="header" href="#events-4">Events</a></h2>
<h3 id="vaultdeployed-1"><a class="header" href="#vaultdeployed-1">VaultDeployed</a></h3>
<p>Emitted when a new vault is deployed</p>
<pre><code class="language-solidity">event VaultDeployed(address vault, address asset, address gauge);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>vault</code></td><td><code>address</code></td><td>Address of the deployed vault</td></tr>
<tr><td><code>asset</code></td><td><code>address</code></td><td>Address of the underlying asset</td></tr>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>Address of the associated gauge</td></tr>
</tbody></table>
</div>
<h2 id="errors-9"><a class="header" href="#errors-9">Errors</a></h2>
<h3 id="invalidgauge"><a class="header" href="#invalidgauge">InvalidGauge</a></h3>
<p>Error thrown when the gauge is not a valid candidate</p>
<pre><code class="language-solidity">error InvalidGauge();
</code></pre>
<h3 id="approvefailed"><a class="header" href="#approvefailed">ApproveFailed</a></h3>
<p>Error thrown when the approve fails</p>
<pre><code class="language-solidity">error ApproveFailed();
</code></pre>
<h3 id="invalidtoken"><a class="header" href="#invalidtoken">InvalidToken</a></h3>
<p>Error thrown when the token is not valid</p>
<pre><code class="language-solidity">error InvalidToken();
</code></pre>
<h3 id="invaliddeployment"><a class="header" href="#invaliddeployment">InvalidDeployment</a></h3>
<p>Error thrown when the deployment is not valid</p>
<pre><code class="language-solidity">error InvalidDeployment();
</code></pre>
<h3 id="alreadydeployed"><a class="header" href="#alreadydeployed">AlreadyDeployed</a></h3>
<p>Error thrown when the gauge has been already used</p>
<pre><code class="language-solidity">error AlreadyDeployed();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protocolcontext"><a class="header" href="#protocolcontext">ProtocolContext</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/ProtocolContext.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
<a href="src/ProtocolContext.sol//src/interfaces/IProtocolContext.sol/interface.IProtocolContext.html">IProtocolContext</a></p>
<p><strong>Author:</strong>
Stake DAO</p>
<p>Base contract that handles common protocol-related logic for Strategy and Harvester</p>
<p><em>Provides shared functionality for handling GATEWAY and LOCKER relationships</em></p>
<h2 id="state-variables-18"><a class="header" href="#state-variables-18">State Variables</a></h2>
<h3 id="protocol_id-2"><a class="header" href="#protocol_id-2">PROTOCOL_ID</a></h3>
<p>The protocol identifier</p>
<pre><code class="language-solidity">bytes4 public immutable PROTOCOL_ID;
</code></pre>
<h3 id="locker-2"><a class="header" href="#locker-2">LOCKER</a></h3>
<p>The locker contract address</p>
<pre><code class="language-solidity">address public immutable LOCKER;
</code></pre>
<h3 id="gateway-2"><a class="header" href="#gateway-2">GATEWAY</a></h3>
<p>The gateway contract address</p>
<pre><code class="language-solidity">address public immutable GATEWAY;
</code></pre>
<h3 id="accountant-3"><a class="header" href="#accountant-3">ACCOUNTANT</a></h3>
<p>The accountant contract address</p>
<pre><code class="language-solidity">address public immutable ACCOUNTANT;
</code></pre>
<h3 id="reward_token-3"><a class="header" href="#reward_token-3">REWARD_TOKEN</a></h3>
<p>The reward token address</p>
<pre><code class="language-solidity">address public immutable REWARD_TOKEN;
</code></pre>
<h3 id="protocol_controller-2"><a class="header" href="#protocol_controller-2">PROTOCOL_CONTROLLER</a></h3>
<p>The protocol controller contract</p>
<pre><code class="language-solidity">IProtocolController public immutable PROTOCOL_CONTROLLER;
</code></pre>
<h2 id="functions-34"><a class="header" href="#functions-34">Functions</a></h2>
<h3 id="constructor-13"><a class="header" href="#constructor-13">constructor</a></h3>
<p>Initializes the base contract with protocol ID, controller, locker, and gateway</p>
<p><strong>Note:</strong>
throws: ZeroAddress If the protocol controller or gateway address is zero</p>
<pre><code class="language-solidity">constructor(bytes4 _protocolId, address _protocolController, address _locker, address _gateway);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_protocolId</code></td><td><code>bytes4</code></td><td>The protocol identifier</td></tr>
<tr><td><code>_protocolController</code></td><td><code>address</code></td><td>The protocol controller contract address</td></tr>
<tr><td><code>_locker</code></td><td><code>address</code></td><td>The locker contract address (can be zero, in which case GATEWAY is used)</td></tr>
<tr><td><code>_gateway</code></td><td><code>address</code></td><td>The gateway contract address</td></tr>
</tbody></table>
</div>
<h3 id="_executetransaction"><a class="header" href="#_executetransaction">_executeTransaction</a></h3>
<p>Executes a transaction through the gateway/module manager</p>
<p><em>Handles the common pattern of executing transactions through the gateway/module manager
based on whether LOCKER is the same as GATEWAY</em></p>
<pre><code class="language-solidity">function _executeTransaction(address target, bytes memory data) internal returns (bool success);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>target</code></td><td><code>address</code></td><td>The address of the contract to interact with</td></tr>
<tr><td><code>data</code></td><td><code>bytes</code></td><td>The calldata to send to the target</td></tr>
</tbody></table>
</div>
<h2 id="errors-10"><a class="header" href="#errors-10">Errors</a></h2>
<h3 id="zeroaddress"><a class="header" href="#zeroaddress">ZeroAddress</a></h3>
<p>Error thrown when a required address is zero</p>
<pre><code class="language-solidity">error ZeroAddress();
</code></pre>
<h3 id="invalidprotocolid-1"><a class="header" href="#invalidprotocolid-1">InvalidProtocolId</a></h3>
<p>Error thrown when a protocol ID is zero</p>
<pre><code class="language-solidity">error InvalidProtocolId();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protocolcontroller"><a class="header" href="#protocolcontroller">ProtocolController</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/ProtocolController.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
<a href="src/ProtocolController.sol//src/interfaces/IProtocolController.sol/interface.IProtocolController.html">IProtocolController</a>, Ownable2Step</p>
<p><strong>Author:</strong>
Stake DAO</p>
<p>Central registry for protocol components and permissions management</p>
<p><em>Manages protocol components, permissions, and shutdown functionality</em></p>
<h2 id="state-variables-19"><a class="header" href="#state-variables-19">State Variables</a></h2>
<h3 id="gauge"><a class="header" href="#gauge">gauge</a></h3>
<p>Mapping of gauge address to Gauge struct</p>
<pre><code class="language-solidity">mapping(address =&gt; Gauge) public gauge;
</code></pre>
<h3 id="registrar"><a class="header" href="#registrar">registrar</a></h3>
<p>Mapping of registrar addresses to their permission status (1 = allowed, 0 = not allowed)</p>
<pre><code class="language-solidity">mapping(address =&gt; bool) public registrar;
</code></pre>
<h3 id="permissionsetters-1"><a class="header" href="#permissionsetters-1">permissionSetters</a></h3>
<p>Mapping of addresses that can set permissions</p>
<pre><code class="language-solidity">mapping(address =&gt; bool) public permissionSetters;
</code></pre>
<h3 id="_protocolcomponents"><a class="header" href="#_protocolcomponents">_protocolComponents</a></h3>
<p>Mapping of protocol ID to its components</p>
<pre><code class="language-solidity">mapping(bytes4 =&gt; ProtocolComponents) internal _protocolComponents;
</code></pre>
<h3 id="_isvalidallocationtargets"><a class="header" href="#_isvalidallocationtargets">_isValidAllocationTargets</a></h3>
<p>Mapping of gauge address to its valid allocation targets</p>
<pre><code class="language-solidity">mapping(address =&gt; mapping(address =&gt; bool)) internal _isValidAllocationTargets;
</code></pre>
<h3 id="_permissions"><a class="header" href="#_permissions">_permissions</a></h3>
<p>Mapping of contract to caller to function selector to permission</p>
<pre><code class="language-solidity">mapping(address =&gt; mapping(address =&gt; mapping(bytes4 =&gt; bool))) internal _permissions;
</code></pre>
<h3 id="component_id_accountant"><a class="header" href="#component_id_accountant">COMPONENT_ID_ACCOUNTANT</a></h3>
<pre><code class="language-solidity">string internal constant COMPONENT_ID_ACCOUNTANT = &quot;Accountant&quot;;
</code></pre>
<h3 id="component_id_fee_receiver"><a class="header" href="#component_id_fee_receiver">COMPONENT_ID_FEE_RECEIVER</a></h3>
<pre><code class="language-solidity">string internal constant COMPONENT_ID_FEE_RECEIVER = &quot;FeeReceiver&quot;;
</code></pre>
<h3 id="component_id_harvester"><a class="header" href="#component_id_harvester">COMPONENT_ID_HARVESTER</a></h3>
<pre><code class="language-solidity">string internal constant COMPONENT_ID_HARVESTER = &quot;Harvester&quot;;
</code></pre>
<h3 id="component_id_allocator"><a class="header" href="#component_id_allocator">COMPONENT_ID_ALLOCATOR</a></h3>
<pre><code class="language-solidity">string internal constant COMPONENT_ID_ALLOCATOR = &quot;Allocator&quot;;
</code></pre>
<h3 id="component_id_strategy"><a class="header" href="#component_id_strategy">COMPONENT_ID_STRATEGY</a></h3>
<pre><code class="language-solidity">string internal constant COMPONENT_ID_STRATEGY = &quot;Strategy&quot;;
</code></pre>
<h2 id="functions-35"><a class="header" href="#functions-35">Functions</a></h2>
<h3 id="onlyregistrar"><a class="header" href="#onlyregistrar">onlyRegistrar</a></h3>
<p>Modifier to restrict function access to registrars or owner</p>
<p><strong>Note:</strong>
reverts: OnlyRegistrar if the caller is not a registrar</p>
<pre><code class="language-solidity">modifier onlyRegistrar();
</code></pre>
<h3 id="onlystrategy"><a class="header" href="#onlystrategy">onlyStrategy</a></h3>
<pre><code class="language-solidity">modifier onlyStrategy(address _gauge);
</code></pre>
<h3 id="onlypermissionsetter"><a class="header" href="#onlypermissionsetter">onlyPermissionSetter</a></h3>
<p>Modifier to restrict function access to permission setters or owner</p>
<p><strong>Note:</strong>
reverts: NotPermissionSetter if the caller is not a permission setter</p>
<pre><code class="language-solidity">modifier onlyPermissionSetter();
</code></pre>
<h3 id="constructor-14"><a class="header" href="#constructor-14">constructor</a></h3>
<p>Constructor for the ProtocolController</p>
<p><em>Initializes the owner of the contract</em></p>
<pre><code class="language-solidity">constructor() Ownable(msg.sender);
</code></pre>
<h3 id="setregistrar"><a class="header" href="#setregistrar">setRegistrar</a></h3>
<p>Sets or revokes registrar permission for an address</p>
<p><strong>Note:</strong>
reverts: ZeroAddress if the registrar address is zero</p>
<pre><code class="language-solidity">function setRegistrar(address _registrar, bool _allowed) external onlyOwner;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_registrar</code></td><td><code>address</code></td><td>The registrar address</td></tr>
<tr><td><code>_allowed</code></td><td><code>bool</code></td><td>Whether the registrar is allowed to register vaults</td></tr>
</tbody></table>
</div>
<h3 id="setpermissionsetter-1"><a class="header" href="#setpermissionsetter-1">setPermissionSetter</a></h3>
<p>Sets or revokes permission setter status for an address</p>
<p><strong>Note:</strong>
reverts: ZeroAddress Throws an error if the permission setter address is zero</p>
<pre><code class="language-solidity">function setPermissionSetter(address _setter, bool _allowed) external onlyOwner;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_setter</code></td><td><code>address</code></td><td>The permission setter address</td></tr>
<tr><td><code>_allowed</code></td><td><code>bool</code></td><td>Whether the address is allowed to set permissions</td></tr>
</tbody></table>
</div>
<h3 id="setpermission-1"><a class="header" href="#setpermission-1">setPermission</a></h3>
<p>Sets a permission for a contract, caller, and function selector</p>
<p><strong>Note:</strong>
reverts: ZeroAddress if the contract or caller address is zero</p>
<pre><code class="language-solidity">function setPermission(address _contract, address _caller, bytes4 _selector, bool _allowed)
    external
    onlyPermissionSetter;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_contract</code></td><td><code>address</code></td><td>The contract address</td></tr>
<tr><td><code>_caller</code></td><td><code>address</code></td><td>The caller address</td></tr>
<tr><td><code>_selector</code></td><td><code>bytes4</code></td><td>The function selector</td></tr>
<tr><td><code>_allowed</code></td><td><code>bool</code></td><td>Whether the caller is allowed to call the function</td></tr>
</tbody></table>
</div>
<h3 id="setstrategy"><a class="header" href="#setstrategy">setStrategy</a></h3>
<p>Sets a protocol strategy</p>
<p><strong>Note:</strong>
reverts: ZeroAddress if the strategy address is zero</p>
<pre><code class="language-solidity">function setStrategy(bytes4 protocolId, address _strategy) external onlyOwner;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>protocolId</code></td><td><code>bytes4</code></td><td>The protocol identifier</td></tr>
<tr><td><code>_strategy</code></td><td><code>address</code></td><td>The strategy address</td></tr>
</tbody></table>
</div>
<h3 id="setallocator"><a class="header" href="#setallocator">setAllocator</a></h3>
<p>Sets a protocol allocator</p>
<p><strong>Note:</strong>
reverts: ZeroAddress if the allocator address is zero</p>
<pre><code class="language-solidity">function setAllocator(bytes4 protocolId, address _allocator) external onlyOwner;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>protocolId</code></td><td><code>bytes4</code></td><td>The protocol identifier</td></tr>
<tr><td><code>_allocator</code></td><td><code>address</code></td><td>The allocator address</td></tr>
</tbody></table>
</div>
<h3 id="setaccountant"><a class="header" href="#setaccountant">setAccountant</a></h3>
<p>Sets a protocol accountant</p>
<p><strong>Note:</strong>
reverts: ZeroAddress if the accountant address is zero</p>
<pre><code class="language-solidity">function setAccountant(bytes4 protocolId, address _accountant) external onlyOwner;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>protocolId</code></td><td><code>bytes4</code></td><td>The protocol identifier</td></tr>
<tr><td><code>_accountant</code></td><td><code>address</code></td><td>The accountant address</td></tr>
</tbody></table>
</div>
<h3 id="setfeereceiver-1"><a class="header" href="#setfeereceiver-1">setFeeReceiver</a></h3>
<p>Sets a protocol fee receiver</p>
<p><strong>Note:</strong>
reverts: ZeroAddress if the fee receiver address is zero</p>
<pre><code class="language-solidity">function setFeeReceiver(bytes4 protocolId, address _feeReceiver) external onlyOwner;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>protocolId</code></td><td><code>bytes4</code></td><td>The protocol identifier</td></tr>
<tr><td><code>_feeReceiver</code></td><td><code>address</code></td><td>The fee receiver address</td></tr>
</tbody></table>
</div>
<h3 id="registervault-1"><a class="header" href="#registervault-1">registerVault</a></h3>
<p>Registers a vault for a gauge</p>
<p><em>Can only be called by the owner or by the authorized registrar contracts</em></p>
<p><strong>Note:</strong>
reverts: ZeroAddress if the gauge, vault, asset, or reward receiver address is zero</p>
<pre><code class="language-solidity">function registerVault(address _gauge, address _vault, address _asset, address _rewardReceiver, bytes4 _protocolId)
    external
    onlyRegistrar;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_gauge</code></td><td><code>address</code></td><td>The gauge address</td></tr>
<tr><td><code>_vault</code></td><td><code>address</code></td><td>The vault address</td></tr>
<tr><td><code>_asset</code></td><td><code>address</code></td><td>The asset address</td></tr>
<tr><td><code>_rewardReceiver</code></td><td><code>address</code></td><td>The reward receiver address</td></tr>
<tr><td><code>_protocolId</code></td><td><code>bytes4</code></td><td>The protocol identifier for the gauge</td></tr>
</tbody></table>
</div>
<h3 id="setvalidallocationtarget-1"><a class="header" href="#setvalidallocationtarget-1">setValidAllocationTarget</a></h3>
<p>Sets a valid allocation target for a gauge</p>
<p><strong>Note:</strong>
reverts: OnlyRegistrar if the caller is not a registrar</p>
<pre><code class="language-solidity">function setValidAllocationTarget(address _gauge, address _target) external onlyRegistrar;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_gauge</code></td><td><code>address</code></td><td>The gauge address</td></tr>
<tr><td><code>_target</code></td><td><code>address</code></td><td>The target address</td></tr>
</tbody></table>
</div>
<h3 id="removevalidallocationtarget-1"><a class="header" href="#removevalidallocationtarget-1">removeValidAllocationTarget</a></h3>
<p>Removes a valid allocation target for a gauge</p>
<p><strong>Note:</strong>
reverts: OnlyRegistrar if the caller is not a registrar</p>
<pre><code class="language-solidity">function removeValidAllocationTarget(address _gauge, address _target) external onlyRegistrar;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_gauge</code></td><td><code>address</code></td><td>The gauge address</td></tr>
<tr><td><code>_target</code></td><td><code>address</code></td><td>The target address</td></tr>
</tbody></table>
</div>
<h3 id="shutdown-1"><a class="header" href="#shutdown-1">shutdown</a></h3>
<p>Shuts down a gauge</p>
<p><strong>Note:</strong>
reverts: OnlyOwner if the caller is not the owner</p>
<pre><code class="language-solidity">function shutdown(address _gauge) external onlyOwner;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_gauge</code></td><td><code>address</code></td><td>The gauge address to shut down</td></tr>
</tbody></table>
</div>
<h3 id="markgaugeasfullywithdrawn-1"><a class="header" href="#markgaugeasfullywithdrawn-1">markGaugeAsFullyWithdrawn</a></h3>
<p>Marks a gauge as fully withdrawn</p>
<p><strong>Note:</strong>
reverts: OnlyStrategy if the caller is not the strategy</p>
<pre><code class="language-solidity">function markGaugeAsFullyWithdrawn(address _gauge) external onlyStrategy(_gauge);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_gauge</code></td><td><code>address</code></td><td>The gauge address</td></tr>
</tbody></table>
</div>
<h3 id="shutdownprotocol"><a class="header" href="#shutdownprotocol">shutdownProtocol</a></h3>
<p>Shuts down a protocol</p>
<p><strong>Note:</strong>
reverts: OnlyOwner if the caller is not the owner</p>
<pre><code class="language-solidity">function shutdownProtocol(bytes4 protocolId) external onlyOwner;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>protocolId</code></td><td><code>bytes4</code></td><td>The protocol identifier</td></tr>
</tbody></table>
</div>
<h3 id="strategy-1"><a class="header" href="#strategy-1">strategy</a></h3>
<p>Returns the strategy address for a protocol</p>
<pre><code class="language-solidity">function strategy(bytes4 protocolId) external view returns (address);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>protocolId</code></td><td><code>bytes4</code></td><td>The protocol identifier</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>address</code></td><td>_ The strategy address</td></tr>
</tbody></table>
</div>
<h3 id="allocator-2"><a class="header" href="#allocator-2">allocator</a></h3>
<p>Returns the allocator address for a protocol</p>
<pre><code class="language-solidity">function allocator(bytes4 protocolId) external view returns (address);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>protocolId</code></td><td><code>bytes4</code></td><td>The protocol identifier</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>address</code></td><td>_ The allocator address</td></tr>
</tbody></table>
</div>
<h3 id="accountant-4"><a class="header" href="#accountant-4">accountant</a></h3>
<p>Returns the accountant address for a protocol</p>
<pre><code class="language-solidity">function accountant(bytes4 protocolId) external view returns (address);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>protocolId</code></td><td><code>bytes4</code></td><td>The protocol identifier</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>address</code></td><td>_ The accountant address</td></tr>
</tbody></table>
</div>
<h3 id="feereceiver-1"><a class="header" href="#feereceiver-1">feeReceiver</a></h3>
<p>Returns the fee receiver address for a protocol</p>
<pre><code class="language-solidity">function feeReceiver(bytes4 protocolId) external view returns (address);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>protocolId</code></td><td><code>bytes4</code></td><td>The protocol identifier</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>address</code></td><td>_ The fee receiver address</td></tr>
</tbody></table>
</div>
<h3 id="isregistrar-1"><a class="header" href="#isregistrar-1">isRegistrar</a></h3>
<p>Checks if an address is an authorized registrar</p>
<pre><code class="language-solidity">function isRegistrar(address _registrar) external view returns (bool);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_registrar</code></td><td><code>address</code></td><td>The address to check</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>bool</code></td><td>_ Whether the address is an authorized registrar</td></tr>
</tbody></table>
</div>
<h3 id="vaults-2"><a class="header" href="#vaults-2">vaults</a></h3>
<p>Returns the vault address for a gauge</p>
<pre><code class="language-solidity">function vaults(address _gauge) external view returns (address);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_gauge</code></td><td><code>address</code></td><td>The gauge address</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>address</code></td><td>_The vault address</td></tr>
</tbody></table>
</div>
<h3 id="rewardreceiver-2"><a class="header" href="#rewardreceiver-2">rewardReceiver</a></h3>
<p>Returns the reward receiver address for a gauge</p>
<pre><code class="language-solidity">function rewardReceiver(address _gauge) external view returns (address);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_gauge</code></td><td><code>address</code></td><td>The gauge address</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>address</code></td><td>_The reward receiver address</td></tr>
</tbody></table>
</div>
<h3 id="asset-3"><a class="header" href="#asset-3">asset</a></h3>
<p>Returns the asset address for a gauge</p>
<pre><code class="language-solidity">function asset(address _gauge) external view returns (address);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_gauge</code></td><td><code>address</code></td><td>The gauge address</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>address</code></td><td>_ The asset address</td></tr>
</tbody></table>
</div>
<h3 id="allowed-1"><a class="header" href="#allowed-1">allowed</a></h3>
<p>Checks if a caller is allowed to call a function on a contract</p>
<pre><code class="language-solidity">function allowed(address _contract, address _caller, bytes4 _selector) external view returns (bool);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_contract</code></td><td><code>address</code></td><td>The contract address</td></tr>
<tr><td><code>_caller</code></td><td><code>address</code></td><td>The caller address</td></tr>
<tr><td><code>_selector</code></td><td><code>bytes4</code></td><td>The function selector</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>bool</code></td><td>_ Whether the caller is allowed</td></tr>
</tbody></table>
</div>
<h3 id="isshutdownprotocol"><a class="header" href="#isshutdownprotocol">isShutdownProtocol</a></h3>
<p>Checks if a protocol is shutdown</p>
<pre><code class="language-solidity">function isShutdownProtocol(bytes4 protocolId) external view returns (bool);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>protocolId</code></td><td><code>bytes4</code></td><td>The protocol identifier</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>bool</code></td><td>_ Whether the protocol is shutdown</td></tr>
</tbody></table>
</div>
<h3 id="isshutdown-1"><a class="header" href="#isshutdown-1">isShutdown</a></h3>
<p>Checks if a gauge is shutdown</p>
<pre><code class="language-solidity">function isShutdown(address _gauge) external view returns (bool);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_gauge</code></td><td><code>address</code></td><td>The gauge address</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>bool</code></td><td>_ Whether the gauge is shutdown</td></tr>
</tbody></table>
</div>
<h3 id="isfullywithdrawn-1"><a class="header" href="#isfullywithdrawn-1">isFullyWithdrawn</a></h3>
<p>Checks if a gauge is fully withdrawn</p>
<pre><code class="language-solidity">function isFullyWithdrawn(address _gauge) external view returns (bool);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_gauge</code></td><td><code>address</code></td><td>The gauge address</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>bool</code></td><td>_ Whether the gauge is fully withdrawn</td></tr>
</tbody></table>
</div>
<h3 id="isvalidallocationtarget-1"><a class="header" href="#isvalidallocationtarget-1">isValidAllocationTarget</a></h3>
<p>Checks if a target is a valid allocation target for a gauge</p>
<pre><code class="language-solidity">function isValidAllocationTarget(address _gauge, address _target) external view returns (bool);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_gauge</code></td><td><code>address</code></td><td>The gauge address</td></tr>
<tr><td><code>_target</code></td><td><code>address</code></td><td>The target address</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>bool</code></td><td>_ Whether the target is a valid allocation target</td></tr>
</tbody></table>
</div>
<h2 id="events-5"><a class="header" href="#events-5">Events</a></h2>
<h3 id="protocolcomponentset"><a class="header" href="#protocolcomponentset">ProtocolComponentSet</a></h3>
<p>Event emitted when a protocol component is set</p>
<pre><code class="language-solidity">event ProtocolComponentSet(bytes4 indexed protocolId, string indexed COMPONENT_ID, address indexed component);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>protocolId</code></td><td><code>bytes4</code></td><td>The protocol identifier</td></tr>
<tr><td><code>COMPONENT_ID</code></td><td><code>string</code></td><td>The component identifier (&quot;Strategy&quot;, &quot;Allocator&quot;, &quot;Harvester&quot;, &quot;Accountant&quot;, &quot;FeeReceiver&quot;)</td></tr>
<tr><td><code>component</code></td><td><code>address</code></td><td>The component address</td></tr>
</tbody></table>
</div>
<h3 id="vaultregistered"><a class="header" href="#vaultregistered">VaultRegistered</a></h3>
<p>Event emitted when a vault is registered</p>
<pre><code class="language-solidity">event VaultRegistered(
    address indexed gauge, address indexed vault, address indexed asset, address rewardReceiver, bytes4 protocolId
);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The gauge address</td></tr>
<tr><td><code>vault</code></td><td><code>address</code></td><td>The vault address</td></tr>
<tr><td><code>asset</code></td><td><code>address</code></td><td>The asset address</td></tr>
<tr><td><code>rewardReceiver</code></td><td><code>address</code></td><td>The reward receiver address</td></tr>
<tr><td><code>protocolId</code></td><td><code>bytes4</code></td><td>The protocol identifier</td></tr>
</tbody></table>
</div>
<h3 id="gaugeshutdown"><a class="header" href="#gaugeshutdown">GaugeShutdown</a></h3>
<p>Event emitted when a gauge is shutdown</p>
<pre><code class="language-solidity">event GaugeShutdown(address indexed gauge);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The gauge address</td></tr>
</tbody></table>
</div>
<h3 id="protocolshutdown"><a class="header" href="#protocolshutdown">ProtocolShutdown</a></h3>
<p>Event emitted when a protocol is shutdown</p>
<pre><code class="language-solidity">event ProtocolShutdown(bytes4 indexed protocolId);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>protocolId</code></td><td><code>bytes4</code></td><td>The protocol identifier</td></tr>
</tbody></table>
</div>
<h3 id="permissionset"><a class="header" href="#permissionset">PermissionSet</a></h3>
<p>Event emitted when a permission is set</p>
<pre><code class="language-solidity">event PermissionSet(address indexed contractAddress, address indexed caller, bytes4 indexed selector, bool allowed);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>contractAddress</code></td><td><code>address</code></td><td>The contract address</td></tr>
<tr><td><code>caller</code></td><td><code>address</code></td><td>The caller address</td></tr>
<tr><td><code>selector</code></td><td><code>bytes4</code></td><td>The function selector</td></tr>
<tr><td><code>allowed</code></td><td><code>bool</code></td><td>Whether the registrar is allowed to register vaults</td></tr>
</tbody></table>
</div>
<h3 id="registrarpermissionset"><a class="header" href="#registrarpermissionset">RegistrarPermissionSet</a></h3>
<p>Event emitted when a registrar permission is set</p>
<pre><code class="language-solidity">event RegistrarPermissionSet(address indexed registrar, bool allowed);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>registrar</code></td><td><code>address</code></td><td>The registrar address</td></tr>
<tr><td><code>allowed</code></td><td><code>bool</code></td><td>Whether the registrar is allowed to register vaults</td></tr>
</tbody></table>
</div>
<h3 id="permissionsetterset"><a class="header" href="#permissionsetterset">PermissionSetterSet</a></h3>
<p>Event emitted when a permission setter is set</p>
<pre><code class="language-solidity">event PermissionSetterSet(address indexed setter, bool allowed);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>setter</code></td><td><code>address</code></td><td>The permission setter address</td></tr>
<tr><td><code>allowed</code></td><td><code>bool</code></td><td>Whether the permission setter is allowed to set permissions</td></tr>
</tbody></table>
</div>
<h2 id="errors-11"><a class="header" href="#errors-11">Errors</a></h2>
<h3 id="onlystrategy-1"><a class="header" href="#onlystrategy-1">OnlyStrategy</a></h3>
<p>Thrown when a non-strategy calls a strategy-only function</p>
<pre><code class="language-solidity">error OnlyStrategy();
</code></pre>
<h3 id="onlyregistrar-1"><a class="header" href="#onlyregistrar-1">OnlyRegistrar</a></h3>
<p>Thrown when a non-registrar calls a registrar-only function</p>
<pre><code class="language-solidity">error OnlyRegistrar();
</code></pre>
<h3 id="zeroaddress-1"><a class="header" href="#zeroaddress-1">ZeroAddress</a></h3>
<p>Thrown when a zero address is used</p>
<pre><code class="language-solidity">error ZeroAddress();
</code></pre>
<h3 id="accountantalreadyset"><a class="header" href="#accountantalreadyset">AccountantAlreadySet</a></h3>
<p>Thrown when an accountant is already set</p>
<pre><code class="language-solidity">error AccountantAlreadySet();
</code></pre>
<h3 id="notpermissionsetter"><a class="header" href="#notpermissionsetter">NotPermissionSetter</a></h3>
<p>Thrown when an unauthorized address tries to set permissions</p>
<pre><code class="language-solidity">error NotPermissionSetter();
</code></pre>
<h3 id="gaugealreadyshutdown"><a class="header" href="#gaugealreadyshutdown">GaugeAlreadyShutdown</a></h3>
<p>Thrown when a gauge is already shutdown</p>
<pre><code class="language-solidity">error GaugeAlreadyShutdown();
</code></pre>
<h3 id="invalidallocationtarget"><a class="header" href="#invalidallocationtarget">InvalidAllocationTarget</a></h3>
<p>Thrown when an invalid allocation target is set</p>
<pre><code class="language-solidity">error InvalidAllocationTarget();
</code></pre>
<h3 id="protocolalreadyshutdown"><a class="header" href="#protocolalreadyshutdown">ProtocolAlreadyShutdown</a></h3>
<p>Thrown when a protocol is already shutdown</p>
<pre><code class="language-solidity">error ProtocolAlreadyShutdown();
</code></pre>
<h3 id="gaugealreadyfullywithdrawn"><a class="header" href="#gaugealreadyfullywithdrawn">GaugeAlreadyFullyWithdrawn</a></h3>
<p>Thrown when a gauge is already fully withdrawn</p>
<pre><code class="language-solidity">error GaugeAlreadyFullyWithdrawn();
</code></pre>
<h2 id="structs-5"><a class="header" href="#structs-5">Structs</a></h2>
<h3 id="protocolcomponents"><a class="header" href="#protocolcomponents">ProtocolComponents</a></h3>
<p>Struct to store protocol components</p>
<pre><code class="language-solidity">struct ProtocolComponents {
    address strategy;
    address allocator;
    address accountant;
    address feeReceiver;
    bool isShutdown;
}
</code></pre>
<h3 id="gauge-1"><a class="header" href="#gauge-1">Gauge</a></h3>
<p>Struct to store gauge-related information</p>
<pre><code class="language-solidity">struct Gauge {
    address vault;
    address asset;
    address rewardReceiver;
    bytes4 protocolId;
    bool isShutdown;
    bool isFullyWithdrawn;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rewardreceiver-3"><a class="header" href="#rewardreceiver-3">RewardReceiver</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/RewardReceiver.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
<a href="src/RewardReceiver.sol//src/interfaces/IRewardReceiver.sol/interface.IRewardReceiver.html">IRewardReceiver</a></p>
<p>A contract that receives rewards from gauges and forwards them to a reward vault.</p>
<p>*Implements a minimal proxy pattern because each reward vault is associated with its reward receiver.
Key responsibilities:</p>
<ul>
<li>Receives extra reward tokens from gauges.</li>
<li>Forwards rewards to reward vault.</li>
<li>Validates reward tokens against the vault's accepted tokens.*</li>
</ul>
<h2 id="functions-36"><a class="header" href="#functions-36">Functions</a></h2>
<h3 id="rewardvault"><a class="header" href="#rewardvault">rewardVault</a></h3>
<p>Address of the reward vault contract.</p>
<pre><code class="language-solidity">function rewardVault() public view returns (IRewardVault _rewardVault);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_rewardVault</code></td><td><code>IRewardVault</code></td><td>The address of the reward vault contract.</td></tr>
</tbody></table>
</div>
<h3 id="distributerewards-1"><a class="header" href="#distributerewards-1">distributeRewards</a></h3>
<p>Distributes all rewards to the reward vault.</p>
<p><em>Iterates through all reward tokens registered in the vault,
checks balances, and forwards any available rewards.
This function is typically called after a gauge has sent rewards to this contract.</em></p>
<pre><code class="language-solidity">function distributeRewards() external;
</code></pre>
<h3 id="distributerewardtoken-1"><a class="header" href="#distributerewardtoken-1">distributeRewardToken</a></h3>
<p>Distributes a specific reward token to the reward vault.</p>
<p><em>Validates that the token is accepted by the vault before attempting distribution.
This function is useful when only a specific reward token needs to be distributed.</em></p>
<p><strong>Note:</strong>
throws: InvalidToken If the token is not registered as a valid reward token in the vault.</p>
<pre><code class="language-solidity">function distributeRewardToken(IERC20 token) external;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>token</code></td><td><code>IERC20</code></td><td>The reward token to distribute.</td></tr>
</tbody></table>
</div>
<h3 id="_depositrewards"><a class="header" href="#_depositrewards">_depositRewards</a></h3>
<p>Deposit rewards to the reward vault.</p>
<pre><code class="language-solidity">function _depositRewards(IERC20 token, uint128 amount) internal;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>token</code></td><td><code>IERC20</code></td><td>The reward token to deposit.</td></tr>
<tr><td><code>amount</code></td><td><code>uint128</code></td><td>The amount of rewards to deposit.</td></tr>
</tbody></table>
</div>
<h2 id="errors-12"><a class="header" href="#errors-12">Errors</a></h2>
<h3 id="invalidtoken-1"><a class="header" href="#invalidtoken-1">InvalidToken</a></h3>
<p>Throws if the reward token is not valid.</p>
<pre><code class="language-solidity">error InvalidToken();
</code></pre>
<h3 id="norewards"><a class="header" href="#norewards">NoRewards</a></h3>
<p>Throws if there are no rewards to distribute.</p>
<pre><code class="language-solidity">error NoRewards();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rewardvault-1"><a class="header" href="#rewardvault-1">RewardVault</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/RewardVault.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
<a href="src/RewardVault.sol//src/interfaces/IRewardVault.sol/interface.IRewardVault.html">IRewardVault</a>, IERC4626, ERC20</p>
<p>An ERC4626-compatible vault that handles:</p>
<ol>
<li>Asset deposits and withdrawals with 1:1 share ratio</li>
<li>Multiple reward token distributions with customizable periods</li>
<li>Integration with Stake DAO's protocol controller and strategy system</li>
</ol>
<p>*Key features:</p>
<ul>
<li>ERC4626 compliance for standardized vault operations</li>
<li>Reward distribution with configurable periods and rates</li>
<li>Integration with protocol controller for strategy management</li>
<li>Automated reward checkpointing on transfers*</li>
</ul>
<h2 id="state-variables-20"><a class="header" href="#state-variables-20">State Variables</a></h2>
<h3 id="default_rewards_duration"><a class="header" href="#default_rewards_duration">DEFAULT_REWARDS_DURATION</a></h3>
<p>Default duration for reward distribution periods</p>
<pre><code class="language-solidity">uint32 public constant DEFAULT_REWARDS_DURATION = 7 days;
</code></pre>
<h3 id="protocol_id-3"><a class="header" href="#protocol_id-3">PROTOCOL_ID</a></h3>
<p>A unique identifier for the protocol/strategy type</p>
<p><em>Used by the protocol controller to route operations to the correct strategy implementation</em></p>
<pre><code class="language-solidity">bytes4 public immutable PROTOCOL_ID;
</code></pre>
<h3 id="accountant-5"><a class="header" href="#accountant-5">ACCOUNTANT</a></h3>
<p>Reference to the Accountant contract for managing balances and rewards</p>
<p><em>Handles all balance-related operations and reward calculations</em></p>
<pre><code class="language-solidity">IAccountant public immutable ACCOUNTANT;
</code></pre>
<h3 id="protocol_controller-3"><a class="header" href="#protocol_controller-3">PROTOCOL_CONTROLLER</a></h3>
<p>Reference to the ProtocolController for protocol-wide coordination</p>
<p><em>Controls strategy routing, permissions, and protocol-wide settings</em></p>
<pre><code class="language-solidity">IProtocolController public immutable PROTOCOL_CONTROLLER;
</code></pre>
<h3 id="policy"><a class="header" href="#policy">POLICY</a></h3>
<p>The harvest policy. Whether to harvest rewards on deposit/withdraw.</p>
<pre><code class="language-solidity">IStrategy.HarvestPolicy public immutable POLICY;
</code></pre>
<h3 id="rewardtokens"><a class="header" href="#rewardtokens">rewardTokens</a></h3>
<p>Array of all reward token addresses supported by this vault</p>
<pre><code class="language-solidity">address[] internal rewardTokens;
</code></pre>
<h3 id="rewarddata"><a class="header" href="#rewarddata">rewardData</a></h3>
<p>Mapping of reward token address to its distribution data</p>
<p><em>Stores all parameters and state for each reward token's distribution</em></p>
<pre><code class="language-solidity">mapping(address rewardToken =&gt; RewardData rewardData) public rewardData;
</code></pre>
<h3 id="accountdata-1"><a class="header" href="#accountdata-1">accountData</a></h3>
<p>Double mapping for storing user reward data per token</p>
<p><em>Maps user address =&gt; reward token =&gt; reward accounting data</em></p>
<pre><code class="language-solidity">mapping(address account =&gt; mapping(address rewardToken =&gt; AccountData accountData)) public accountData;
</code></pre>
<h2 id="functions-37"><a class="header" href="#functions-37">Functions</a></h2>
<h3 id="onlyallowed-2"><a class="header" href="#onlyallowed-2">onlyAllowed</a></h3>
<p>Modifier to check if the caller is allowed by the protocol controller to do a specific action</p>
<p><strong>Note:</strong>
reverts: OnlyAllowed if the caller is not allowed.</p>
<pre><code class="language-solidity">modifier onlyAllowed();
</code></pre>
<h3 id="onlyregistrar-2"><a class="header" href="#onlyregistrar-2">onlyRegistrar</a></h3>
<p>Modifier to check if the caller is a registrar</p>
<p><strong>Note:</strong>
reverts: OnlyRegistrar if the caller is not a registrar</p>
<pre><code class="language-solidity">modifier onlyRegistrar();
</code></pre>
<h3 id="constructor-15"><a class="header" href="#constructor-15">constructor</a></h3>
<p>Initializes the vault with basic ERC20 metadata</p>
<p><em>Sets up the vault with a standard name and symbol prefix</em></p>
<p><strong>Note:</strong>
reverts: ZeroAddress if the accountant or protocol controller address is the zero address.</p>
<pre><code class="language-solidity">constructor(bytes4 protocolId, address protocolController, address accountant, IStrategy.HarvestPolicy policy)
    ERC20(&quot;&quot;, &quot;&quot;);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>protocolId</code></td><td><code>bytes4</code></td><td>The protocol ID.</td></tr>
<tr><td><code>protocolController</code></td><td><code>address</code></td><td>The protocol controller address</td></tr>
<tr><td><code>accountant</code></td><td><code>address</code></td><td>The accountant address</td></tr>
<tr><td><code>policy</code></td><td><code>IStrategy.HarvestPolicy</code></td><td>The harvest policy.</td></tr>
</tbody></table>
</div>
<h3 id="deposit-7"><a class="header" href="#deposit-7">deposit</a></h3>
<pre><code class="language-solidity">function deposit(uint256 assets, address receiver) external returns (uint256);
</code></pre>
<h3 id="deposit-8"><a class="header" href="#deposit-8">deposit</a></h3>
<p>Deposits <code>assets</code> from <code>msg.sender</code> into the vault and mints shares to <code>receiver</code>.</p>
<p><em>This function tracks the referrer address and handles deposit allocation through strategy and updates rewards.</em></p>
<pre><code class="language-solidity">function deposit(uint256 assets, address receiver, address referrer) public returns (uint256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>assets</code></td><td><code>uint256</code></td><td>The amount of assets to deposit.</td></tr>
<tr><td><code>receiver</code></td><td><code>address</code></td><td>The address to receive the minted shares. If the receiver is the zero address, the shares will be minted to the caller.</td></tr>
<tr><td><code>referrer</code></td><td><code>address</code></td><td>The address of the referrer. Can be the zero address.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>_ The amount of assets deposited.</td></tr>
</tbody></table>
</div>
<h3 id="mint"><a class="header" href="#mint">mint</a></h3>
<p>Mints exact <code>shares</code> to <code>receiver</code> by depositing assets.</p>
<p><em>Due to the 1:1 relationship between the assets and the shares,
the mint function is a wrapper of the deposit function.</em></p>
<pre><code class="language-solidity">function mint(uint256 shares, address receiver, address referrer) external returns (uint256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>shares</code></td><td><code>uint256</code></td><td>The amount of shares to mint.</td></tr>
<tr><td><code>receiver</code></td><td><code>address</code></td><td>The address to receive the minted shares.</td></tr>
<tr><td><code>referrer</code></td><td><code>address</code></td><td>The address of the referrer. Can be the zero address.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>_ The amount of shares minted.</td></tr>
</tbody></table>
</div>
<h3 id="mint-1"><a class="header" href="#mint-1">mint</a></h3>
<p>Mints exact <code>shares</code> to <code>receiver</code> by depositing assets.</p>
<p><em>Due to the 1:1 relationship between the assets and the shares,
the mint function is a wrapper of the deposit function.</em></p>
<pre><code class="language-solidity">function mint(uint256 shares, address receiver) external returns (uint256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>shares</code></td><td><code>uint256</code></td><td>The amount of shares to mint.</td></tr>
<tr><td><code>receiver</code></td><td><code>address</code></td><td>The address to receive the minted shares.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>_ The amount of shares minted.</td></tr>
</tbody></table>
</div>
<h3 id="deposit-9"><a class="header" href="#deposit-9">deposit</a></h3>
<p>Deposits <code>assets</code> from <code>account</code> into the vault and mints shares to <code>account</code>.</p>
<p><em>Only callable by allowed addresses. <code>account</code> should have approved this contract to transfer <code>assets</code>.
This function tracks the referrer address and handles deposit allocation through strategy and updates rewards.</em></p>
<p><strong>Note:</strong>
reverts: ZeroAddress if the account or receiver address is the zero address.</p>
<pre><code class="language-solidity">function deposit(address account, address receiver, uint256 assets, address referrer)
    public
    onlyAllowed
    returns (uint256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>account</code></td><td><code>address</code></td><td>The address to deposit assets from and mint shares to.</td></tr>
<tr><td><code>receiver</code></td><td><code>address</code></td><td>The address to receive the minted shares.</td></tr>
<tr><td><code>assets</code></td><td><code>uint256</code></td><td>The amount of assets to deposit.</td></tr>
<tr><td><code>referrer</code></td><td><code>address</code></td><td>The address of the referrer. Can be the zero address.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>_ The amount of assets deposited.</td></tr>
</tbody></table>
</div>
<h3 id="_deposit-2"><a class="header" href="#_deposit-2">_deposit</a></h3>
<p>~ DEPOSIT - INTERNAL</p>
<p>*Internal function to deposit assets into the vault.</p>
<ol>
<li>Update the reward state for the receiver.</li>
<li>Get the deposit allocation.</li>
<li>Transfer assets to the targets.</li>
<li>Trigger deposit on the strategy.</li>
<li>Mint shares (accountant checkpoint).</li>
<li>Emit Deposit event.*</li>
</ol>
<pre><code class="language-solidity">function _deposit(address account, address receiver, uint256 assets, uint256 shares, address referrer) internal;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>account</code></td><td><code>address</code></td><td>The address of the account to deposit assets from.</td></tr>
<tr><td><code>receiver</code></td><td><code>address</code></td><td>The address to receive the minted shares.</td></tr>
<tr><td><code>assets</code></td><td><code>uint256</code></td><td>The amount of assets to deposit.</td></tr>
<tr><td><code>shares</code></td><td><code>uint256</code></td><td>The amount of shares to mint.</td></tr>
<tr><td><code>referrer</code></td><td><code>address</code></td><td>The address of the referrer. Can be the zero address.</td></tr>
</tbody></table>
</div>
<h3 id="withdraw-6"><a class="header" href="#withdraw-6">withdraw</a></h3>
<p>Withdraws <code>assets</code> from the vault to <code>receiver</code> by burning shares from <code>owner</code>.</p>
<p><em>Checks allowances and calls strategy withdrawal logic.</em></p>
<p><strong>Note:</strong>
reverts: NotApproved if the caller is not allowed to withdraw at least the amount of assets given.</p>
<pre><code class="language-solidity">function withdraw(uint256 assets, address receiver, address owner) public returns (uint256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>assets</code></td><td><code>uint256</code></td><td>The amount of assets to withdraw.</td></tr>
<tr><td><code>receiver</code></td><td><code>address</code></td><td>The address to receive the assets. If the receiver is the zero address, the assets will be sent to the owner.</td></tr>
<tr><td><code>owner</code></td><td><code>address</code></td><td>The address to burn shares from.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>_ The amount of assets withdrawn.</td></tr>
</tbody></table>
</div>
<h3 id="redeem"><a class="header" href="#redeem">redeem</a></h3>
<p>Redeems <code>shares</code> from <code>owner</code> and sends assets to <code>receiver</code>.</p>
<p><em>Checks allowances and calls strategy withdrawal logic. Due to the 1:1
relationship of the assets and the shares, the redeem function is a
wrapper of the withdraw function.</em></p>
<pre><code class="language-solidity">function redeem(uint256 shares, address receiver, address owner) external returns (uint256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>shares</code></td><td><code>uint256</code></td><td>The amount of shares to redeem.</td></tr>
<tr><td><code>receiver</code></td><td><code>address</code></td><td>The address to receive the assets.</td></tr>
<tr><td><code>owner</code></td><td><code>address</code></td><td>The address to burn shares from.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>_ The amount of shares burned.</td></tr>
</tbody></table>
</div>
<h3 id="_withdraw-2"><a class="header" href="#_withdraw-2">_withdraw</a></h3>
<p><em>Internal function to withdraw assets from the vault.</em></p>
<pre><code class="language-solidity">function _withdraw(address owner, address receiver, uint256 assets, uint256 shares) internal;
</code></pre>
<h3 id="claim-13"><a class="header" href="#claim-13">claim</a></h3>
<p>Claims rewards for multiple tokens in a single transaction</p>
<p><em>Updates reward state and transfers claimed rewards to the receiver</em></p>
<pre><code class="language-solidity">function claim(address[] calldata tokens, address receiver) public returns (uint256[] memory amounts);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>tokens</code></td><td><code>address[]</code></td><td>Array of reward token addresses to claim</td></tr>
<tr><td><code>receiver</code></td><td><code>address</code></td><td>Address to receive the claimed rewards (defaults to msg.sender if zero)</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>amounts</code></td><td><code>uint256[]</code></td><td>Array of amounts claimed for each token, in the same order as input tokens</td></tr>
</tbody></table>
</div>
<h3 id="claim-14"><a class="header" href="#claim-14">claim</a></h3>
<p>Claims rewards on behalf of another account (requires authorization)</p>
<p><em>Only callable by addresses allowed by the protocol controller</em></p>
<p><strong>Note:</strong>
reverts: OnlyAllowed if caller is not authorized</p>
<pre><code class="language-solidity">function claim(address account, address[] calldata tokens, address receiver)
    public
    onlyAllowed
    returns (uint256[] memory amounts);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>account</code></td><td><code>address</code></td><td>Address to claim rewards for</td></tr>
<tr><td><code>tokens</code></td><td><code>address[]</code></td><td>Array of reward token addresses to claim</td></tr>
<tr><td><code>receiver</code></td><td><code>address</code></td><td>Address to receive the claimed rewards</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>amounts</code></td><td><code>uint256[]</code></td><td>Array of amounts claimed for each token</td></tr>
</tbody></table>
</div>
<h3 id="_claim-2"><a class="header" href="#_claim-2">_claim</a></h3>
<p><em>Core reward claiming implementation</em></p>
<p><strong>Note:</strong>
reverts: InvalidRewardToken if any token is not registered</p>
<pre><code class="language-solidity">function _claim(address account, address[] calldata tokens, address receiver)
    internal
    returns (uint256[] memory amounts);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>account</code></td><td><code>address</code></td><td>Account whose rewards are being claimed</td></tr>
<tr><td><code>tokens</code></td><td><code>address[]</code></td><td>Array of reward tokens to process</td></tr>
<tr><td><code>receiver</code></td><td><code>address</code></td><td>Destination for the claimed rewards</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>amounts</code></td><td><code>uint256[]</code></td><td>Array of claimed amounts per token</td></tr>
</tbody></table>
</div>
<h3 id="addrewardtoken-1"><a class="header" href="#addrewardtoken-1">addRewardToken</a></h3>
<p>Registers a new reward token with the vault</p>
<p><em>Only callable by protocol registrars</em></p>
<p><strong>Notes:</strong></p>
<ul>
<li>
<p>reverts: OnlyRegistrar if caller is not a registrar</p>
</li>
<li>
<p>reverts: ZeroAddress if distributor is zero address</p>
</li>
<li>
<p>reverts: MaxRewardTokensExceeded if MAX_REWARD_TOKEN_COUNT would be exceeded</p>
</li>
<li>
<p>reverts: RewardAlreadyExists if token is already registered</p>
</li>
</ul>
<pre><code class="language-solidity">function addRewardToken(address rewardToken, address distributor) external onlyRegistrar;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>rewardToken</code></td><td><code>address</code></td><td>Address of the reward token to add</td></tr>
<tr><td><code>distributor</code></td><td><code>address</code></td><td>Address authorized to manage rewards for this token</td></tr>
</tbody></table>
</div>
<h3 id="depositrewards-1"><a class="header" href="#depositrewards-1">depositRewards</a></h3>
<p>Deposits new rewards for distribution</p>
<p><em>Calculates new reward rate and updates distribution schedule</em></p>
<p><strong>Note:</strong>
reverts: UnauthorizedRewardsDistributor if caller is not the authorized distributor</p>
<pre><code class="language-solidity">function depositRewards(address rewardToken, uint128 amount) external;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>rewardToken</code></td><td><code>address</code></td><td>Address of the reward token being deposited</td></tr>
<tr><td><code>amount</code></td><td><code>uint128</code></td><td>Amount of rewards to distribute</td></tr>
</tbody></table>
</div>
<h3 id="checkpoint-5"><a class="header" href="#checkpoint-5">checkpoint</a></h3>
<p>Updates reward state for a single account</p>
<p><em>Wrapper around _checkpoint for single account updates</em></p>
<pre><code class="language-solidity">function checkpoint(address account) external;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>account</code></td><td><code>address</code></td><td>Account to update rewards for</td></tr>
</tbody></table>
</div>
<h3 id="_checkpoint"><a class="header" href="#_checkpoint">_checkpoint</a></h3>
<p>Updates reward state for specified accounts</p>
<p><em>Core function for maintaining reward distribution state</em></p>
<pre><code class="language-solidity">function _checkpoint(address _from, address _to) internal;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_from</code></td><td><code>address</code></td><td>First account to update (can be address(0) to skip)</td></tr>
<tr><td><code>_to</code></td><td><code>address</code></td><td>Second account to update (can be address(0) to skip)</td></tr>
</tbody></table>
</div>
<h3 id="_updaterewardtoken"><a class="header" href="#_updaterewardtoken">_updateRewardToken</a></h3>
<p>Updates the reward state for a specific token</p>
<p><em>Calculates and stores new reward per token value</em></p>
<pre><code class="language-solidity">function _updateRewardToken(address token) internal returns (uint128 newRewardPerToken);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>token</code></td><td><code>address</code></td><td>The reward token to update</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>newRewardPerToken</code></td><td><code>uint128</code></td><td>The newly calculated reward per token value</td></tr>
</tbody></table>
</div>
<h3 id="_updateaccountdata"><a class="header" href="#_updateaccountdata">_updateAccountData</a></h3>
<p>Updates an account's reward data for a specific token</p>
<p><em>Calculates and stores earned rewards since last update</em></p>
<pre><code class="language-solidity">function _updateAccountData(address account, address token, uint128 newRewardPerToken) internal;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>account</code></td><td><code>address</code></td><td>The account to update</td></tr>
<tr><td><code>token</code></td><td><code>address</code></td><td>The reward token to process</td></tr>
<tr><td><code>newRewardPerToken</code></td><td><code>uint128</code></td><td>Current reward per token value</td></tr>
</tbody></table>
</div>
<h3 id="_isrewardtoken"><a class="header" href="#_isrewardtoken">_isRewardToken</a></h3>
<p>Checks if a reward token is properly registered</p>
<p><em>A token is considered registered if it has a non-zero distributor</em></p>
<pre><code class="language-solidity">function _isRewardToken(RewardData storage reward) internal view returns (bool);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>reward</code></td><td><code>RewardData</code></td><td>Storage pointer to the reward data</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>bool</code></td><td>True if the reward token is registered</td></tr>
</tbody></table>
</div>
<h3 id="_lasttimerewardapplicable"><a class="header" href="#_lasttimerewardapplicable">_lastTimeRewardApplicable</a></h3>
<p>Calculates the latest timestamp for reward distribution</p>
<p><em>Returns the earlier of current time or period finish</em></p>
<pre><code class="language-solidity">function _lastTimeRewardApplicable(uint32 periodFinish) internal view returns (uint32);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>periodFinish</code></td><td><code>uint32</code></td><td>The timestamp when the reward period ends</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint32</code></td><td>The latest timestamp for reward calculations</td></tr>
</tbody></table>
</div>
<h3 id="_rewardpertoken"><a class="header" href="#_rewardpertoken">_rewardPerToken</a></h3>
<p>Calculates the current reward per token value</p>
<p><em>Accounts for time elapsed and total supply</em></p>
<pre><code class="language-solidity">function _rewardPerToken(RewardData storage reward) internal view returns (uint128);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>reward</code></td><td><code>RewardData</code></td><td>Storage pointer to the reward data</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint128</code></td><td>Current reward per token, scaled by 1e18</td></tr>
</tbody></table>
</div>
<h3 id="_earned"><a class="header" href="#_earned">_earned</a></h3>
<p>Calculates earned rewards for an account</p>
<p><em>Includes both stored claimable amount and newly earned rewards</em></p>
<pre><code class="language-solidity">function _earned(address account, address token, uint128 userClaimable, uint128 userRewardPerTokenPaid)
    internal
    view
    returns (uint128);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>account</code></td><td><code>address</code></td><td>The account to calculate rewards for</td></tr>
<tr><td><code>token</code></td><td><code>address</code></td><td>The reward token to calculate</td></tr>
<tr><td><code>userClaimable</code></td><td><code>uint128</code></td><td>Previously stored claimable amount</td></tr>
<tr><td><code>userRewardPerTokenPaid</code></td><td><code>uint128</code></td><td>Last checkpoint of reward per token for user</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint128</code></td><td>Total earned rewards as uint128</td></tr>
</tbody></table>
</div>
<h3 id="isrewardtoken-1"><a class="header" href="#isrewardtoken-1">isRewardToken</a></h3>
<p>Checks if a reward token exists.</p>
<p><em>The check is based on the assumption that the distributor is always set for a
active address and it can not be zero.</em></p>
<pre><code class="language-solidity">function isRewardToken(address rewardToken) public view returns (bool);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>rewardToken</code></td><td><code>address</code></td><td>The address of the reward token to check.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>bool</code></td><td>_ True if the reward token exists, false otherwise.</td></tr>
</tbody></table>
</div>
<h3 id="asset-4"><a class="header" href="#asset-4">asset</a></h3>
<p>Returns the address of the underlying token.</p>
<p><em>Retrieves the token address from the clone's immutable args.</em></p>
<pre><code class="language-solidity">function asset() public view returns (address);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>address</code></td><td>_ The address of the underlying token used by the vault.</td></tr>
</tbody></table>
</div>
<h3 id="totalassets-1"><a class="header" href="#totalassets-1">totalAssets</a></h3>
<p>Returns the total amount of underlying assets (1:1 with total shares).</p>
<p><em>Due to the 1:1 relationship between assets and shares, the total assets
is the same as the total supply.</em></p>
<pre><code class="language-solidity">function totalAssets() external view returns (uint256);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>_ The total amount of underlying assets.</td></tr>
</tbody></table>
</div>
<h3 id="converttoshares"><a class="header" href="#converttoshares">convertToShares</a></h3>
<p>Converts a given number of assets to the equivalent amount of shares (1:1).</p>
<p><em>Due to the 1:1 relationship between assets and shares, the conversion is the same.</em></p>
<pre><code class="language-solidity">function convertToShares(uint256 assets) external pure returns (uint256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>assets</code></td><td><code>uint256</code></td><td>The amount of assets to convert to shares.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>_ The amount of shares that would be received for the given amount of assets. Basically the same value as the assets parameter.</td></tr>
</tbody></table>
</div>
<h3 id="converttoassets"><a class="header" href="#converttoassets">convertToAssets</a></h3>
<p>Converts a given number of shares to the equivalent amount of assets (1:1).</p>
<p><em>Due to the 1:1 relationship between assets and shares, the conversion is the same.</em></p>
<pre><code class="language-solidity">function convertToAssets(uint256 shares) external pure returns (uint256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>shares</code></td><td><code>uint256</code></td><td>The amount of shares to convert to assets.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>_ The amount of assets that would be received for the given amount of shares. Basically the same value as the shares parameter.</td></tr>
</tbody></table>
</div>
<h3 id="previewdeposit"><a class="header" href="#previewdeposit">previewDeposit</a></h3>
<p>Returns the amount of assets that would be received for a given amount of shares.</p>
<p><em>Due to the 1:1 relationship between assets and shares, the amount of assets
received is the same as the amount of shares deposited.</em></p>
<pre><code class="language-solidity">function previewDeposit(uint256 shares) external pure returns (uint256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>shares</code></td><td><code>uint256</code></td><td>The amount of shares to deposit.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>_ The amount of assets that would be received for the given amount of shares. Basically the same value as the shares parameter.</td></tr>
</tbody></table>
</div>
<h3 id="previewmint"><a class="header" href="#previewmint">previewMint</a></h3>
<p>Returns the amount of shares that would be received for a given amount of assets.</p>
<p><em>Due to the 1:1 relationship between assets and shares, the amount of shares
received is the same as the amount of assets deposited.</em></p>
<pre><code class="language-solidity">function previewMint(uint256 assets) external pure returns (uint256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>assets</code></td><td><code>uint256</code></td><td>The amount of assets to mint.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>_ The amount of shares that would be received for the given amount of assets. Basically the same value as the assets parameter.</td></tr>
</tbody></table>
</div>
<h3 id="previewwithdraw"><a class="header" href="#previewwithdraw">previewWithdraw</a></h3>
<p>Returns the amount of shares that would be received for a given amount of assets.</p>
<p><em>Due to the 1:1 relationship between assets and shares, the amount of shares
received is the same as the amount of assets withdrawn.</em></p>
<pre><code class="language-solidity">function previewWithdraw(uint256 assets) external pure returns (uint256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>assets</code></td><td><code>uint256</code></td><td>The amount of assets to withdraw.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>_ The amount of shares that would be received for the given amount of assets. Basically the same value as the assets parameter.</td></tr>
</tbody></table>
</div>
<h3 id="previewredeem"><a class="header" href="#previewredeem">previewRedeem</a></h3>
<p>Returns the amount of assets that would be received for a given amount of shares.</p>
<p><em>Due to the 1:1 relationship between assets and shares, the amount of tokens
received is the same as the amount of shares redeemed.</em></p>
<pre><code class="language-solidity">function previewRedeem(uint256 shares) external pure returns (uint256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>shares</code></td><td><code>uint256</code></td><td>The amount of shares to redeem.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>_ The amount of assets that would be received for the given amount of shares. Basically the same value as the shares parameter.</td></tr>
</tbody></table>
</div>
<h3 id="maxdeposit"><a class="header" href="#maxdeposit">maxDeposit</a></h3>
<p>Returns the maximum amount of assets that can be deposited.</p>
<p><em>The parameter is not used and is included to satisfy the interface. Pass whatever you want to.</em></p>
<pre><code class="language-solidity">function maxDeposit(address) public pure returns (uint256);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>_ The maximum amount of assets that can be deposited.</td></tr>
</tbody></table>
</div>
<h3 id="maxmint"><a class="header" href="#maxmint">maxMint</a></h3>
<p>Returns the maximum amount of shares that can be minted.</p>
<p><em>Due to the 1:1 relationship between assets and shares, the max mint
is the same as the max deposit.</em></p>
<pre><code class="language-solidity">function maxMint(address _account) external pure returns (uint256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_account</code></td><td><code>address</code></td><td>The address of the account to calculate the max mint for.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>_ The maximum amount of shares that can be minted.</td></tr>
</tbody></table>
</div>
<h3 id="maxwithdraw"><a class="header" href="#maxwithdraw">maxWithdraw</a></h3>
<p>Returns the maximum amount of assets that can be withdrawn.</p>
<pre><code class="language-solidity">function maxWithdraw(address owner) public view returns (uint256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>owner</code></td><td><code>address</code></td><td>The address of the owner to calculate the max withdraw for.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>_ The maximum amount of assets that can be withdrawn.</td></tr>
</tbody></table>
</div>
<h3 id="maxredeem"><a class="header" href="#maxredeem">maxRedeem</a></h3>
<p>Returns the maximum amount of shares that can be redeemed.</p>
<p><em>Due to the 1:1 relationship between assets and shares, the max redeem
is the same as the max withdraw.</em></p>
<pre><code class="language-solidity">function maxRedeem(address owner) external view returns (uint256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>owner</code></td><td><code>address</code></td><td>The address of the owner to calculate the max redeem for.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>_ The maximum amount of shares that can be redeemed.</td></tr>
</tbody></table>
</div>
<h3 id="getrewardsdistributor-1"><a class="header" href="#getrewardsdistributor-1">getRewardsDistributor</a></h3>
<p>Returns the distributor address for a given reward token.</p>
<pre><code class="language-solidity">function getRewardsDistributor(address token) external view returns (address);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>token</code></td><td><code>address</code></td><td>The address of the reward token to calculate the distributor address for.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>address</code></td><td>_ The distributor address for the given reward token.</td></tr>
</tbody></table>
</div>
<h3 id="getlastupdatetime-1"><a class="header" href="#getlastupdatetime-1">getLastUpdateTime</a></h3>
<p>Returns the last update time for a given reward token.</p>
<pre><code class="language-solidity">function getLastUpdateTime(address token) external view returns (uint32);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>token</code></td><td><code>address</code></td><td>The address of the reward token to calculate the last update time for.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint32</code></td><td>_ The last update time for the given reward token.</td></tr>
</tbody></table>
</div>
<h3 id="getperiodfinish-1"><a class="header" href="#getperiodfinish-1">getPeriodFinish</a></h3>
<p>Returns the period finish time for a given reward token.</p>
<pre><code class="language-solidity">function getPeriodFinish(address token) external view returns (uint32);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>token</code></td><td><code>address</code></td><td>The address of the reward token to calculate the period finish time for.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint32</code></td><td>_ The period finish time for the given reward token.</td></tr>
</tbody></table>
</div>
<h3 id="getrewardrate-1"><a class="header" href="#getrewardrate-1">getRewardRate</a></h3>
<p>Returns the reward rate for a given reward token.</p>
<pre><code class="language-solidity">function getRewardRate(address token) external view returns (uint128);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>token</code></td><td><code>address</code></td><td>The address of the reward token to calculate the reward rate for.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint128</code></td><td>_ The reward rate for the given reward token.</td></tr>
</tbody></table>
</div>
<h3 id="getrewardpertokenstored-1"><a class="header" href="#getrewardpertokenstored-1">getRewardPerTokenStored</a></h3>
<p>Returns the reward per token stored for a given reward token.</p>
<pre><code class="language-solidity">function getRewardPerTokenStored(address token) external view returns (uint128);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>token</code></td><td><code>address</code></td><td>The address of the reward token to calculate the reward per token stored for.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint128</code></td><td>_ The reward per token stored for the given reward token.</td></tr>
</tbody></table>
</div>
<h3 id="getrewardpertokenpaid-1"><a class="header" href="#getrewardpertokenpaid-1">getRewardPerTokenPaid</a></h3>
<p>Returns the reward per token paid for a given reward token and account.</p>
<pre><code class="language-solidity">function getRewardPerTokenPaid(address token, address account) external view returns (uint128);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>token</code></td><td><code>address</code></td><td>The address of the reward token to calculate the reward per token paid for.</td></tr>
<tr><td><code>account</code></td><td><code>address</code></td><td>The address of the account to calculate the reward per token paid for.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint128</code></td><td>_ The reward per token paid for the given reward token and account.</td></tr>
</tbody></table>
</div>
<h3 id="getclaimable-1"><a class="header" href="#getclaimable-1">getClaimable</a></h3>
<p>Returns the claimable amount for a given reward token and account.</p>
<pre><code class="language-solidity">function getClaimable(address token, address account) external view returns (uint128);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>token</code></td><td><code>address</code></td><td>The address of the reward token to calculate the claimable amount for.</td></tr>
<tr><td><code>account</code></td><td><code>address</code></td><td>The address of the account to calculate the claimable amount for.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint128</code></td><td>_ The claimable amount for the given reward token and account.</td></tr>
</tbody></table>
</div>
<h3 id="getrewardtokens-3"><a class="header" href="#getrewardtokens-3">getRewardTokens</a></h3>
<pre><code class="language-solidity">function getRewardTokens() external view returns (address[] memory);
</code></pre>
<h3 id="totalsupply-3"><a class="header" href="#totalsupply-3">totalSupply</a></h3>
<p>Returns the total supply of this vault fetched from the accountant contract.</p>
<pre><code class="language-solidity">function totalSupply() public view override(ERC20, IERC20) returns (uint256);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>_ The total supply of this vault.</td></tr>
</tbody></table>
</div>
<h3 id="_safetotalsupply"><a class="header" href="#_safetotalsupply">_safeTotalSupply</a></h3>
<p>Returns the total supply of the vault safely casted as a uint128.</p>
<p><strong>Note:</strong>
reverts: Overflow if the total supply is greater than the maximum value of a uint128.</p>
<pre><code class="language-solidity">function _safeTotalSupply() internal view returns (uint128);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint128</code></td><td>_ The total supply of the vault safely casted as a uint128.</td></tr>
</tbody></table>
</div>
<h3 id="balanceof-6"><a class="header" href="#balanceof-6">balanceOf</a></h3>
<p>Returns the balance of the vault for a given account.</p>
<pre><code class="language-solidity">function balanceOf(address account) public view override(ERC20, IERC20) returns (uint256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>account</code></td><td><code>address</code></td><td>The address of the account to calculate the balance for.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>_ The balance of the vault for the given account.</td></tr>
</tbody></table>
</div>
<h3 id="lasttimerewardapplicable-1"><a class="header" href="#lasttimerewardapplicable-1">lastTimeRewardApplicable</a></h3>
<p>Returns the last time reward is applicable for a given reward token</p>
<p><em>Wrapper around internal _lastTimeRewardApplicable function</em></p>
<pre><code class="language-solidity">function lastTimeRewardApplicable(address token) external view returns (uint256);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>token</code></td><td><code>address</code></td><td>The reward token to check</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>Latest applicable timestamp for rewards</td></tr>
</tbody></table>
</div>
<h3 id="rewardpertoken-1"><a class="header" href="#rewardpertoken-1">rewardPerToken</a></h3>
<p>Returns the reward per token for a given reward token</p>
<p><em>Wrapper around internal _rewardPerToken function</em></p>
<pre><code class="language-solidity">function rewardPerToken(address token) public view returns (uint128);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>token</code></td><td><code>address</code></td><td>The reward token to calculate for</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint128</code></td><td>Current reward per token value</td></tr>
</tbody></table>
</div>
<h3 id="earned-1"><a class="header" href="#earned-1">earned</a></h3>
<p>Calculates total earned rewards for an account</p>
<p><em>Includes both claimed and pending rewards</em></p>
<pre><code class="language-solidity">function earned(address account, address token) external view returns (uint128);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>account</code></td><td><code>address</code></td><td>Account to check rewards for</td></tr>
<tr><td><code>token</code></td><td><code>address</code></td><td>Reward token to calculate</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint128</code></td><td>Total earned rewards</td></tr>
</tbody></table>
</div>
<h3 id="gauge-2"><a class="header" href="#gauge-2">gauge</a></h3>
<p>Retrieves the gauge address from clone arguments</p>
<p><em>Uses assembly to read from clone initialization data</em></p>
<p><strong>Note:</strong>
reverts: CloneArgsNotFound if clone is incorrectly initialized</p>
<pre><code class="language-solidity">function gauge() public view returns (address _gauge);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_gauge</code></td><td><code>address</code></td><td>The gauge contract address</td></tr>
</tbody></table>
</div>
<h3 id="allocator-3"><a class="header" href="#allocator-3">allocator</a></h3>
<p>Gets the allocator contract for this protocol type</p>
<p><em>Fetches from protocol controller using PROTOCOL_ID</em></p>
<pre><code class="language-solidity">function allocator() public view returns (IAllocator _allocator);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_allocator</code></td><td><code>IAllocator</code></td><td>The allocator contract interface</td></tr>
</tbody></table>
</div>
<h3 id="strategy-2"><a class="header" href="#strategy-2">strategy</a></h3>
<p>Gets the strategy contract for this protocol type</p>
<p><em>Fetches from protocol controller using PROTOCOL_ID</em></p>
<pre><code class="language-solidity">function strategy() public view returns (IStrategy _strategy);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_strategy</code></td><td><code>IStrategy</code></td><td>The strategy contract interface</td></tr>
</tbody></table>
</div>
<h3 id="_update"><a class="header" href="#_update">_update</a></h3>
<p>Handles reward state updates during token transfers</p>
<p><em>Updates balances via Accountant and reward states</em></p>
<pre><code class="language-solidity">function _update(address from, address to, uint256 amount) internal override;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>from</code></td><td><code>address</code></td><td>Address sending tokens</td></tr>
<tr><td><code>to</code></td><td><code>address</code></td><td>Address receiving tokens</td></tr>
<tr><td><code>amount</code></td><td><code>uint256</code></td><td>Number of tokens being transferred</td></tr>
</tbody></table>
</div>
<h3 id="_mint"><a class="header" href="#_mint">_mint</a></h3>
<p>Mints new vault shares</p>
<p><em>Updates balances and processes pending rewards</em></p>
<pre><code class="language-solidity">function _mint(
    address to,
    uint256 amount,
    IStrategy.PendingRewards memory pendingRewards,
    IStrategy.HarvestPolicy policy,
    address referrer
) internal;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>to</code></td><td><code>address</code></td><td>Recipient of new shares</td></tr>
<tr><td><code>amount</code></td><td><code>uint256</code></td><td>Amount of shares to mint</td></tr>
<tr><td><code>pendingRewards</code></td><td><code>IStrategy.PendingRewards</code></td><td>Rewards to process during mint</td></tr>
<tr><td><code>policy</code></td><td><code>IStrategy.HarvestPolicy</code></td><td>The harvest policy.</td></tr>
<tr><td><code>referrer</code></td><td><code>address</code></td><td>The address of the referrer. Can be the zero address.</td></tr>
</tbody></table>
</div>
<h3 id="_burn"><a class="header" href="#_burn">_burn</a></h3>
<p>Burns vault shares</p>
<p><em>Updates balances and processes pending rewards</em></p>
<pre><code class="language-solidity">function _burn(
    address from,
    uint256 amount,
    IStrategy.PendingRewards memory pendingRewards,
    IStrategy.HarvestPolicy policy
) internal;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>from</code></td><td><code>address</code></td><td>Address to burn shares from</td></tr>
<tr><td><code>amount</code></td><td><code>uint256</code></td><td>Amount of shares to burn</td></tr>
<tr><td><code>pendingRewards</code></td><td><code>IStrategy.PendingRewards</code></td><td>Rewards to process during burn</td></tr>
<tr><td><code>policy</code></td><td><code>IStrategy.HarvestPolicy</code></td><td>The harvest policy.</td></tr>
</tbody></table>
</div>
<h3 id="name-7"><a class="header" href="#name-7">name</a></h3>
<p>Generates the vault's name</p>
<p><em>Combines &quot;StakeDAO&quot;, underlying asset name, and &quot;Vault&quot;</em></p>
<pre><code class="language-solidity">function name() public view override(ERC20, IERC20Metadata) returns (string memory);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>string</code></td><td>Full vault name</td></tr>
</tbody></table>
</div>
<h3 id="symbol"><a class="header" href="#symbol">symbol</a></h3>
<p>Generates the vault's symbol</p>
<p><em>Combines &quot;sd-&quot;, underlying asset symbol, and &quot;-vault&quot;</em></p>
<pre><code class="language-solidity">function symbol() public view override(ERC20, IERC20Metadata) returns (string memory);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>string</code></td><td>Full vault symbol</td></tr>
</tbody></table>
</div>
<h3 id="decimals"><a class="header" href="#decimals">decimals</a></h3>
<p>Gets the vault's decimal places</p>
<p><em>Matches underlying asset decimals</em></p>
<pre><code class="language-solidity">function decimals() public view override(ERC20, IERC20Metadata) returns (uint8);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint8</code></td><td>Number of decimal places</td></tr>
</tbody></table>
</div>
<h2 id="events-6"><a class="header" href="#events-6">Events</a></h2>
<h3 id="rewardtokenadded"><a class="header" href="#rewardtokenadded">RewardTokenAdded</a></h3>
<p>Emitted when a new reward token is added to the vault</p>
<pre><code class="language-solidity">event RewardTokenAdded(address indexed rewardToken, address indexed distributor);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>rewardToken</code></td><td><code>address</code></td><td>The address of the reward token being added</td></tr>
<tr><td><code>distributor</code></td><td><code>address</code></td><td>The authorized address that can distribute this reward</td></tr>
</tbody></table>
</div>
<h3 id="rewardsdeposited"><a class="header" href="#rewardsdeposited">RewardsDeposited</a></h3>
<p>Emitted when new rewards are deposited for distribution</p>
<pre><code class="language-solidity">event RewardsDeposited(address indexed rewardToken, uint256 amount, uint128 rewardRate);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>rewardToken</code></td><td><code>address</code></td><td>The token being distributed as rewards</td></tr>
<tr><td><code>amount</code></td><td><code>uint256</code></td><td>The total amount of rewards being added</td></tr>
<tr><td><code>rewardRate</code></td><td><code>uint128</code></td><td>The calculated rate at which rewards will be distributed (tokens/second)</td></tr>
</tbody></table>
</div>
<h2 id="errors-13"><a class="header" href="#errors-13">Errors</a></h2>
<h3 id="notapproved"><a class="header" href="#notapproved">NotApproved</a></h3>
<p>Thrown when an operation is attempted by an unauthorized caller</p>
<pre><code class="language-solidity">error NotApproved();
</code></pre>
<h3 id="zeroaddress-2"><a class="header" href="#zeroaddress-2">ZeroAddress</a></h3>
<p>Thrown when a zero address is provided where a valid address is required</p>
<pre><code class="language-solidity">error ZeroAddress();
</code></pre>
<h3 id="onlyallowed-3"><a class="header" href="#onlyallowed-3">OnlyAllowed</a></h3>
<p>Thrown when a function is called by an address not in the allowed list</p>
<pre><code class="language-solidity">error OnlyAllowed();
</code></pre>
<h3 id="onlyregistrar-3"><a class="header" href="#onlyregistrar-3">OnlyRegistrar</a></h3>
<p>Thrown when a function is called by an address that isn't a registrar</p>
<pre><code class="language-solidity">error OnlyRegistrar();
</code></pre>
<h3 id="invalidprotocolid-2"><a class="header" href="#invalidprotocolid-2">InvalidProtocolId</a></h3>
<p>Thrown when a protocol ID is zero</p>
<pre><code class="language-solidity">error InvalidProtocolId();
</code></pre>
<h3 id="targetnotapproved"><a class="header" href="#targetnotapproved">TargetNotApproved</a></h3>
<p>Thrown when attempting to allocate assets to an unapproved target</p>
<pre><code class="language-solidity">error TargetNotApproved();
</code></pre>
<h3 id="invalidrewardtoken-1"><a class="header" href="#invalidrewardtoken-1">InvalidRewardToken</a></h3>
<p>Thrown when attempting to interact with an unregistered reward token</p>
<pre><code class="language-solidity">error InvalidRewardToken();
</code></pre>
<h3 id="rewardalreadyexists"><a class="header" href="#rewardalreadyexists">RewardAlreadyExists</a></h3>
<p>Thrown when attempting to add a reward token that's already registered</p>
<pre><code class="language-solidity">error RewardAlreadyExists();
</code></pre>
<h3 id="unauthorizedrewardsdistributor"><a class="header" href="#unauthorizedrewardsdistributor">UnauthorizedRewardsDistributor</a></h3>
<p>Thrown when an unauthorized address attempts to distribute rewards</p>
<pre><code class="language-solidity">error UnauthorizedRewardsDistributor();
</code></pre>
<h2 id="structs-6"><a class="header" href="#structs-6">Structs</a></h2>
<h3 id="rewarddata-1"><a class="header" href="#rewarddata-1">RewardData</a></h3>
<p>Stores all data related to a specific reward token's distribution</p>
<p><em>Optimized to fit in exactly 2 storage slots (2 * 256 bits)</em></p>
<pre><code class="language-solidity">struct RewardData {
    address rewardsDistributor;
    uint32 lastUpdateTime;
    uint32 periodFinish;
    uint128 rewardRate;
    uint128 rewardPerTokenStored;
}
</code></pre>
<h3 id="accountdata-2"><a class="header" href="#accountdata-2">AccountData</a></h3>
<p>Stores reward accounting data for a specific user and reward token</p>
<p><em>Optimized to fit in exactly 1 storage slot (256 bits)</em></p>
<pre><code class="language-solidity">struct AccountData {
    uint128 rewardPerTokenPaid;
    uint128 claimable;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="router"><a class="header" href="#router">Router</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/Router.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
<a href="src/Router.sol//src/interfaces/IRouter.sol/interface.IRouter.html">IRouter</a>, Ownable</p>
<p>One single entry point for all Staking V2 instances.</p>
<p><em>This contract allows for the execution of arbitrary delegate calls to registered modules.</em></p>
<h2 id="state-variables-21"><a class="header" href="#state-variables-21">State Variables</a></h2>
<h3 id="buffer"><a class="header" href="#buffer">$buffer</a></h3>
<p>The storage buffer for the modules</p>
<p><em>Instead of using a traditional mapping that hashes the key to calculate the slot,
we directly use the unique identifier of each module as the storage slot.
The storage buffer exists to avoid future collisions. Note the owner of this
contract takes one slot in storage (slot 0).
The value of the buffer is equal to the keccak256 hash of the constant
string &quot;STAKEDAO.STAKING.V2.ROUTER.V1&quot;, meaning the modules will be
stored starting at slot <code>0x5fb198ff3ff065a7e746cc70c28b38b1f3eeaf1a559ede71c28b60a0759b061b</code>.
This is a gas cost optimization made possible due to the simplicity of the storage layout.</em></p>
<pre><code class="language-solidity">bytes32 internal constant $buffer = keccak256(&quot;STAKEDAO.STAKING.V2.ROUTER.V1&quot;);
</code></pre>
<h3 id="version-9"><a class="header" href="#version-9">version</a></h3>
<pre><code class="language-solidity">string public constant version = &quot;1.0.0&quot;;
</code></pre>
<h2 id="functions-38"><a class="header" href="#functions-38">Functions</a></h2>
<h3 id="constructor-16"><a class="header" href="#constructor-16">constructor</a></h3>
<pre><code class="language-solidity">constructor() Ownable(msg.sender);
</code></pre>
<h3 id="getstoragebuffer"><a class="header" href="#getstoragebuffer">getStorageBuffer</a></h3>
<p>Gets the storage buffer used to store the modules.
The buffer acts as an offset for the storage of modules.</p>
<pre><code class="language-solidity">function getStorageBuffer() public pure returns (bytes32 buffer);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>buffer</code></td><td><code>bytes32</code></td><td>The storage buffer</td></tr>
</tbody></table>
</div>
<h3 id="setmodule-1"><a class="header" href="#setmodule-1">setModule</a></h3>
<p>Sets a module</p>
<p><em>The module is set at the storage slot <code>buffer + identifier</code>
While not enforced by the code, developers are expected to use
incremental identifiers when setting modules.
This allows modules to be enumerated using the <code>enumerateModules</code> helper.
Note that this is just a convention, and modules should be indexed off-chain for
efficiency and correctness.</em></p>
<p><strong>Note:</strong>
throws: OwnableUnauthorizedAccount if the caller is not the owner</p>
<pre><code class="language-solidity">function setModule(uint8 identifier, address module) public onlyOwner;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>identifier</code></td><td><code>uint8</code></td><td>The unique identifier of the module</td></tr>
<tr><td><code>module</code></td><td><code>address</code></td><td>The address of the module</td></tr>
</tbody></table>
</div>
<h3 id="safesetmodule-1"><a class="header" href="#safesetmodule-1">safeSetModule</a></h3>
<p>Sets a module in safe mode</p>
<p><em>The module can be set to address(0) to erase it</em></p>
<p><strong>Notes:</strong></p>
<ul>
<li>
<p>throws: OwnableUnauthorizedAccount if the caller is not the owner</p>
</li>
<li>
<p>throws: IdentifierAlreadyUsed if the identifier is already set</p>
</li>
</ul>
<pre><code class="language-solidity">function safeSetModule(uint8 identifier, address module) external;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>identifier</code></td><td><code>uint8</code></td><td>The unique identifier of the module</td></tr>
<tr><td><code>module</code></td><td><code>address</code></td><td>The address of the module</td></tr>
</tbody></table>
</div>
<h3 id="getmodule-1"><a class="header" href="#getmodule-1">getModule</a></h3>
<p>Gets the module at the given identifier</p>
<pre><code class="language-solidity">function getModule(uint8 identifier) public view returns (address module);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>identifier</code></td><td><code>uint8</code></td><td>The unique identifier of the module</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>module</code></td><td><code>address</code></td><td>The address of the module. Returns address(0) if the module is not set</td></tr>
</tbody></table>
</div>
<h3 id="getmodulename-1"><a class="header" href="#getmodulename-1">getModuleName</a></h3>
<p>Gets the name of the module at the given identifier</p>
<pre><code class="language-solidity">function getModuleName(uint8 identifier) public view returns (string memory name);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>identifier</code></td><td><code>uint8</code></td><td>The unique identifier of the module</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code></td><td><code>string</code></td><td>The name of the module. Returns an empty string if the module is not set</td></tr>
</tbody></table>
</div>
<h3 id="enumeratemodules"><a class="header" href="#enumeratemodules">enumerateModules</a></h3>
<p>Convenient function to enumerate the incrementally stored modules</p>
<p><em>Never call this function on-chain. It is only meant to be used off-chain for informational purposes.
This function should not replace off-chain indexing of the modules.
This function stops iterating when it encounters address(0). This means that
if the modules are not stored contiguously, this function will return only a subset of the modules.</em></p>
<pre><code class="language-solidity">function enumerateModules() external view returns (bytes memory modules);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>modules</code></td><td><code>bytes</code></td><td>The concatenated addresses of the modules in a bytes array. The length of the returned bytes array is <code>20 * n</code>, where <code>n</code> is the number of modules. Returns an empty bytes array if the first slot is not set.</td></tr>
</tbody></table>
</div>
<h3 id="execute-1"><a class="header" href="#execute-1">execute</a></h3>
<p>Executes a batch of delegate calls to registered modules.</p>
<p>*Each element in the <code>calls</code> array must be encoded as:</p>
<ul>
<li>1 byte: the module identifier (<code>uint8</code>), corresponding to a registered module.</li>
<li>N bytes: Optional ABI-encoded call data using <code>abi.encodeWithSelector(...)</code>, where:</li>
<li>The first 4 bytes represent the function selector.</li>
<li>The remaining bytes (a multiple of 32) represent the function arguments.
Example: <code>bytes.concat(bytes1(identifier), abi.encodeWithSelector(...))</code>
All calls are performed using <code>delegatecall</code>, so state changes affect this contract.*</li>
</ul>
<p><strong>Notes:</strong></p>
<ul>
<li>
<p>throws: OwnableUnauthorizedAccount if the caller is not the owner</p>
</li>
<li>
<p>throws: ModuleNotSet if the module for a given identifier is not set</p>
</li>
<li>
<p>throws: _ if a <code>calls[i]</code> element is empty</p>
</li>
</ul>
<pre><code class="language-solidity">function execute(bytes[] calldata calls) external payable returns (bytes[] memory);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>calls</code></td><td><code>bytes[]</code></td><td>An array of encoded calls. Each call must start with a 1-byte module identifier followed by the ABI-encoded function call data.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>bytes[]</code></td><td>returnData An array containing the returned data for each call, in order.</td></tr>
</tbody></table>
</div>
<h2 id="events-7"><a class="header" href="#events-7">Events</a></h2>
<h3 id="moduleset"><a class="header" href="#moduleset">ModuleSet</a></h3>
<p>Emitted when a module is set</p>
<pre><code class="language-solidity">event ModuleSet(uint8 indexed identifier, address module, string name);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>identifier</code></td><td><code>uint8</code></td><td>The unique identifier of the module (indexed value)</td></tr>
<tr><td><code>module</code></td><td><code>address</code></td><td>The address of the module</td></tr>
<tr><td><code>name</code></td><td><code>string</code></td><td>The name of the module</td></tr>
</tbody></table>
</div>
<h2 id="errors-14"><a class="header" href="#errors-14">Errors</a></h2>
<h3 id="emptymodulename"><a class="header" href="#emptymodulename">EmptyModuleName</a></h3>
<pre><code class="language-solidity">error EmptyModuleName();
</code></pre>
<h3 id="identifieralreadyused"><a class="header" href="#identifieralreadyused">IdentifierAlreadyUsed</a></h3>
<pre><code class="language-solidity">error IdentifierAlreadyUsed(uint8 identifier);
</code></pre>
<h3 id="modulenotset"><a class="header" href="#modulenotset">ModuleNotSet</a></h3>
<pre><code class="language-solidity">error ModuleNotSet(uint8 identifier);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sidecar-1"><a class="header" href="#sidecar-1">Sidecar</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/Sidecar.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
<a href="src/Sidecar.sol//src/interfaces/ISidecar.sol/interface.ISidecar.html">ISidecar</a></p>
<p>A base contract for implementing protocol-specific sidecars</p>
<p><em>Provides core functionality for depositing, withdrawing, and managing assets across different protocols</em></p>
<h2 id="state-variables-22"><a class="header" href="#state-variables-22">State Variables</a></h2>
<h3 id="protocol_id-4"><a class="header" href="#protocol_id-4">PROTOCOL_ID</a></h3>
<p>The protocol identifier</p>
<pre><code class="language-solidity">bytes4 public immutable PROTOCOL_ID;
</code></pre>
<h3 id="accountant-6"><a class="header" href="#accountant-6">ACCOUNTANT</a></h3>
<p>The accountant contract address</p>
<pre><code class="language-solidity">address public immutable ACCOUNTANT;
</code></pre>
<h3 id="reward_token-4"><a class="header" href="#reward_token-4">REWARD_TOKEN</a></h3>
<p>The reward token address</p>
<pre><code class="language-solidity">IERC20 public immutable REWARD_TOKEN;
</code></pre>
<h3 id="protocol_controller-4"><a class="header" href="#protocol_controller-4">PROTOCOL_CONTROLLER</a></h3>
<p>The protocol controller contract</p>
<pre><code class="language-solidity">IProtocolController public immutable PROTOCOL_CONTROLLER;
</code></pre>
<h3 id="_initialized"><a class="header" href="#_initialized">_initialized</a></h3>
<p>Whether the sidecar has been initialized</p>
<pre><code class="language-solidity">bool private _initialized;
</code></pre>
<h2 id="functions-39"><a class="header" href="#functions-39">Functions</a></h2>
<h3 id="onlystrategy-2"><a class="header" href="#onlystrategy-2">onlyStrategy</a></h3>
<p>Ensures the caller is the strategy</p>
<p><strong>Note:</strong>
throws: OnlyStrategy If the caller is not the strategy</p>
<pre><code class="language-solidity">modifier onlyStrategy();
</code></pre>
<h3 id="constructor-17"><a class="header" href="#constructor-17">constructor</a></h3>
<p>Initializes the sidecar with protocol ID, accountant, and protocol controller</p>
<pre><code class="language-solidity">constructor(bytes4 _protocolId, address _accountant, address _protocolController);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_protocolId</code></td><td><code>bytes4</code></td><td>The identifier for the protocol this sidecar interacts with</td></tr>
<tr><td><code>_accountant</code></td><td><code>address</code></td><td>The address of the accountant contract</td></tr>
<tr><td><code>_protocolController</code></td><td><code>address</code></td><td>The address of the protocol controller</td></tr>
</tbody></table>
</div>
<h3 id="initialize"><a class="header" href="#initialize">initialize</a></h3>
<p>Initializes the sidecar</p>
<p><em>Can only be called once</em></p>
<p><strong>Note:</strong>
throws: AlreadyInitialized If the sidecar is already initialized</p>
<pre><code class="language-solidity">function initialize() external;
</code></pre>
<h3 id="deposit-10"><a class="header" href="#deposit-10">deposit</a></h3>
<p>Deposits assets into the sidecar</p>
<p><strong>Note:</strong>
throws: OnlyStrategy If the caller is not the strategy</p>
<pre><code class="language-solidity">function deposit(uint256 amount) external onlyStrategy;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>amount</code></td><td><code>uint256</code></td><td>The amount to deposit</td></tr>
</tbody></table>
</div>
<h3 id="withdraw-7"><a class="header" href="#withdraw-7">withdraw</a></h3>
<p>Withdraws assets from the sidecar</p>
<p><strong>Note:</strong>
throws: OnlyStrategy If the caller is not the strategy</p>
<pre><code class="language-solidity">function withdraw(uint256 amount, address receiver) external onlyStrategy;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>amount</code></td><td><code>uint256</code></td><td>The amount to withdraw</td></tr>
<tr><td><code>receiver</code></td><td><code>address</code></td><td>The address to receive the withdrawn assets</td></tr>
</tbody></table>
</div>
<h3 id="claim-15"><a class="header" href="#claim-15">claim</a></h3>
<p>Claims pending rewards from the sidecar</p>
<p><strong>Note:</strong>
throws: OnlyAccountant If the caller is not the accountant</p>
<pre><code class="language-solidity">function claim() external onlyStrategy returns (uint256);
</code></pre>
<h3 id="asset-5"><a class="header" href="#asset-5">asset</a></h3>
<p>Returns the asset of the sidecar</p>
<pre><code class="language-solidity">function asset() public view virtual returns (IERC20);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>IERC20</code></td><td>The asset of the sidecar</td></tr>
</tbody></table>
</div>
<h3 id="rewardreceiver-4"><a class="header" href="#rewardreceiver-4">rewardReceiver</a></h3>
<p>Returns the reward receiver of the sidecar</p>
<pre><code class="language-solidity">function rewardReceiver() public view virtual returns (address);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>address</code></td><td>The reward receiver of the sidecar</td></tr>
</tbody></table>
</div>
<h3 id="_initialize-1"><a class="header" href="#_initialize-1">_initialize</a></h3>
<p>Initializes the sidecar</p>
<p><em>Must be implemented by derived sidecars to handle protocol-specific initialization</em></p>
<pre><code class="language-solidity">function _initialize() internal virtual;
</code></pre>
<h3 id="_deposit-3"><a class="header" href="#_deposit-3">_deposit</a></h3>
<p>Deposits assets into the sidecar</p>
<p><em>Must be implemented by derived sidecars to handle protocol-specific deposits</em></p>
<pre><code class="language-solidity">function _deposit(uint256 amount) internal virtual;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>amount</code></td><td><code>uint256</code></td><td>The amount to deposit</td></tr>
</tbody></table>
</div>
<h3 id="_claim-3"><a class="header" href="#_claim-3">_claim</a></h3>
<p>Claims pending rewards from the sidecar</p>
<p><em>Must be implemented by derived sidecars to handle protocol-specific claims</em></p>
<pre><code class="language-solidity">function _claim() internal virtual returns (uint256);
</code></pre>
<h3 id="_withdraw-3"><a class="header" href="#_withdraw-3">_withdraw</a></h3>
<p>Withdraws assets from the sidecar</p>
<p><em>Must be implemented by derived sidecars to handle protocol-specific withdrawals</em></p>
<pre><code class="language-solidity">function _withdraw(uint256 amount, address receiver) internal virtual;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>amount</code></td><td><code>uint256</code></td><td>The amount to withdraw</td></tr>
<tr><td><code>receiver</code></td><td><code>address</code></td><td>The address to receive the withdrawn assets</td></tr>
</tbody></table>
</div>
<h3 id="balanceof-7"><a class="header" href="#balanceof-7">balanceOf</a></h3>
<p>Returns the balance of the sidecar</p>
<p><em>Must be implemented by derived sidecars to handle protocol-specific balance calculation</em></p>
<pre><code class="language-solidity">function balanceOf() public view virtual returns (uint256);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>The balance of the sidecar</td></tr>
</tbody></table>
</div>
<h3 id="getpendingrewards-4"><a class="header" href="#getpendingrewards-4">getPendingRewards</a></h3>
<p>Returns the pending rewards of the sidecar</p>
<p><em>Must be implemented by derived sidecars to handle protocol-specific reward calculation</em></p>
<pre><code class="language-solidity">function getPendingRewards() public view virtual returns (uint256);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>The pending rewards of the sidecar</td></tr>
</tbody></table>
</div>
<h2 id="errors-15"><a class="header" href="#errors-15">Errors</a></h2>
<h3 id="zeroaddress-3"><a class="header" href="#zeroaddress-3">ZeroAddress</a></h3>
<p>Error thrown when an address is zero</p>
<pre><code class="language-solidity">error ZeroAddress();
</code></pre>
<h3 id="onlystrategy-3"><a class="header" href="#onlystrategy-3">OnlyStrategy</a></h3>
<p>Error thrown when the caller is not the strategy</p>
<pre><code class="language-solidity">error OnlyStrategy();
</code></pre>
<h3 id="onlyaccountant"><a class="header" href="#onlyaccountant">OnlyAccountant</a></h3>
<p>Error thrown when the caller is not the accountant</p>
<pre><code class="language-solidity">error OnlyAccountant();
</code></pre>
<h3 id="alreadyinitialized"><a class="header" href="#alreadyinitialized">AlreadyInitialized</a></h3>
<p>Error thrown when the sidecar is already initialized</p>
<pre><code class="language-solidity">error AlreadyInitialized();
</code></pre>
<h3 id="notinitialized"><a class="header" href="#notinitialized">NotInitialized</a></h3>
<p>Error thrown when the sidecar is not initialized</p>
<pre><code class="language-solidity">error NotInitialized();
</code></pre>
<h3 id="invalidprotocolid-3"><a class="header" href="#invalidprotocolid-3">InvalidProtocolId</a></h3>
<p>Error thrown when a protocol ID is zero</p>
<pre><code class="language-solidity">error InvalidProtocolId();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sidecarfactory"><a class="header" href="#sidecarfactory">SidecarFactory</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/SidecarFactory.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
<a href="src/SidecarFactory.sol//src/interfaces/ISidecarFactory.sol/interface.ISidecarFactory.html">ISidecarFactory</a></p>
<p>Base factory contract for deploying protocol-specific sidecar instances</p>
<p><em>Creates deterministic minimal proxies for sidecar implementations</em></p>
<h2 id="state-variables-23"><a class="header" href="#state-variables-23">State Variables</a></h2>
<h3 id="protocol_id-5"><a class="header" href="#protocol_id-5">PROTOCOL_ID</a></h3>
<p>The protocol ID</p>
<pre><code class="language-solidity">bytes4 public immutable PROTOCOL_ID;
</code></pre>
<h3 id="protocol_controller-5"><a class="header" href="#protocol_controller-5">PROTOCOL_CONTROLLER</a></h3>
<p>The protocol controller address</p>
<pre><code class="language-solidity">IProtocolController public immutable PROTOCOL_CONTROLLER;
</code></pre>
<h3 id="strategy-3"><a class="header" href="#strategy-3">STRATEGY</a></h3>
<p>The strategy address</p>
<pre><code class="language-solidity">address public immutable STRATEGY;
</code></pre>
<h3 id="accountant-7"><a class="header" href="#accountant-7">ACCOUNTANT</a></h3>
<p>The accountant address</p>
<pre><code class="language-solidity">address public immutable ACCOUNTANT;
</code></pre>
<h3 id="reward_token-5"><a class="header" href="#reward_token-5">REWARD_TOKEN</a></h3>
<p>The reward token address</p>
<pre><code class="language-solidity">address public immutable REWARD_TOKEN;
</code></pre>
<h3 id="implementation"><a class="header" href="#implementation">IMPLEMENTATION</a></h3>
<p>The implementation address</p>
<pre><code class="language-solidity">address public immutable IMPLEMENTATION;
</code></pre>
<h3 id="sidecar-2"><a class="header" href="#sidecar-2">sidecar</a></h3>
<p>Mapping of gauges to sidecars</p>
<pre><code class="language-solidity">mapping(address =&gt; address) public sidecar;
</code></pre>
<h2 id="functions-40"><a class="header" href="#functions-40">Functions</a></h2>
<h3 id="constructor-18"><a class="header" href="#constructor-18">constructor</a></h3>
<p>Constructor</p>
<pre><code class="language-solidity">constructor(bytes4 _protocolId, address _implementation, address _protocolController);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_protocolId</code></td><td><code>bytes4</code></td><td>Protocol ID</td></tr>
<tr><td><code>_implementation</code></td><td><code>address</code></td><td>Address of the sidecar implementation</td></tr>
<tr><td><code>_protocolController</code></td><td><code>address</code></td><td>Address of the protocol controller</td></tr>
</tbody></table>
</div>
<h3 id="create-3"><a class="header" href="#create-3">create</a></h3>
<p>Create a new sidecar for a gauge</p>
<pre><code class="language-solidity">function create(address gauge, bytes memory args) public virtual override returns (address sidecarAddress);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>Gauge address</td></tr>
<tr><td><code>args</code></td><td><code>bytes</code></td><td>Encoded arguments for sidecar creation</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>sidecarAddress</code></td><td><code>address</code></td><td>Address of the created sidecar</td></tr>
</tbody></table>
</div>
<h3 id="_isvalidgauge-3"><a class="header" href="#_isvalidgauge-3">_isValidGauge</a></h3>
<p>Validates the gauge and arguments</p>
<p><em>Must be implemented by derived factories to handle protocol-specific validation</em></p>
<pre><code class="language-solidity">function _isValidGauge(address gauge, bytes memory args) internal virtual;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The gauge to validate</td></tr>
<tr><td><code>args</code></td><td><code>bytes</code></td><td>The arguments to validate</td></tr>
</tbody></table>
</div>
<h3 id="_create-1"><a class="header" href="#_create-1">_create</a></h3>
<p>Creates a sidecar for a gauge</p>
<p><em>Must be implemented by derived factories to handle protocol-specific sidecar creation</em></p>
<pre><code class="language-solidity">function _create(address gauge, bytes memory args) internal virtual returns (address sidecarAddress);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The gauge to create a sidecar for</td></tr>
<tr><td><code>args</code></td><td><code>bytes</code></td><td>The arguments for sidecar creation</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>sidecarAddress</code></td><td><code>address</code></td><td>Address of the created sidecar</td></tr>
</tbody></table>
</div>
<h2 id="events-8"><a class="header" href="#events-8">Events</a></h2>
<h3 id="sidecarcreated"><a class="header" href="#sidecarcreated">SidecarCreated</a></h3>
<p>Event emitted when a new sidecar is created</p>
<pre><code class="language-solidity">event SidecarCreated(address indexed gauge, address indexed sidecar, bytes args);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>Address of the gauge</td></tr>
<tr><td><code>sidecar</code></td><td><code>address</code></td><td>Address of the created sidecar</td></tr>
<tr><td><code>args</code></td><td><code>bytes</code></td><td>Additional arguments used for creation</td></tr>
</tbody></table>
</div>
<h2 id="errors-16"><a class="header" href="#errors-16">Errors</a></h2>
<h3 id="invalidgauge-1"><a class="header" href="#invalidgauge-1">InvalidGauge</a></h3>
<p>Error emitted when the gauge is invalid</p>
<pre><code class="language-solidity">error InvalidGauge();
</code></pre>
<h3 id="invalidtoken-2"><a class="header" href="#invalidtoken-2">InvalidToken</a></h3>
<p>Error emitted when the token is invalid</p>
<pre><code class="language-solidity">error InvalidToken();
</code></pre>
<h3 id="zeroaddress-4"><a class="header" href="#zeroaddress-4">ZeroAddress</a></h3>
<p>Error emitted when a zero address is provided</p>
<pre><code class="language-solidity">error ZeroAddress();
</code></pre>
<h3 id="invalidprotocolid-4"><a class="header" href="#invalidprotocolid-4">InvalidProtocolId</a></h3>
<p>Error emitted when a protocol ID is zero</p>
<pre><code class="language-solidity">error InvalidProtocolId();
</code></pre>
<h3 id="sidecaralreadydeployed"><a class="header" href="#sidecaralreadydeployed">SidecarAlreadyDeployed</a></h3>
<p>Error emitted when the sidecar is already deployed</p>
<pre><code class="language-solidity">error SidecarAlreadyDeployed();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strategy-4"><a class="header" href="#strategy-4">Strategy</a></h1>
<p><a href="https://github.com/stake-dao/contracts-monorepo/blob/1bff79e3ef49fd14fb35b2da27f80c1f6d780c0c/src/Strategy.sol">Git Source</a></p>
<p><strong>Inherits:</strong>
<a href="src/Strategy.sol//src/interfaces/IStrategy.sol/interface.IStrategy.html">IStrategy</a>, <a href="src/Strategy.sol//src/ProtocolContext.sol/contract.ProtocolContext.html">ProtocolContext</a></p>
<p>A base contract for implementing protocol-specific strategies</p>
<p>*Provides core functionality for depositing, withdrawing, and managing assets across different protocols
Key responsibilities:</p>
<ul>
<li>Handles deposits and withdrawals through protocol-specific implementations</li>
<li>Manages gauge allocations across different targets</li>
<li>Tracks and reports pending rewards</li>
<li>Provides emergency shutdown functionality*</li>
</ul>
<h2 id="state-variables-24"><a class="header" href="#state-variables-24">State Variables</a></h2>
<h3 id="flush_amount_slot"><a class="header" href="#flush_amount_slot">FLUSH_AMOUNT_SLOT</a></h3>
<p><em>Slot for the flush amount in transient storage</em></p>
<pre><code class="language-solidity">bytes32 internal constant FLUSH_AMOUNT_SLOT = keccak256(&quot;strategy.flushAmount&quot;);
</code></pre>
<h2 id="functions-41"><a class="header" href="#functions-41">Functions</a></h2>
<h3 id="onlyvault-1"><a class="header" href="#onlyvault-1">onlyVault</a></h3>
<p>Ensures the caller is the vault registered for the gauge</p>
<p><strong>Note:</strong>
throws: OnlyVault If the caller is not the registered vault for the gauge</p>
<pre><code class="language-solidity">modifier onlyVault(address gauge);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The gauge to check vault authorization for</td></tr>
</tbody></table>
</div>
<h3 id="onlyaccountant-1"><a class="header" href="#onlyaccountant-1">onlyAccountant</a></h3>
<p>Ensures the caller is the accountant for the strategy</p>
<p><strong>Note:</strong>
throws: OnlyAccountant If the caller is not the accountant for the strategy</p>
<pre><code class="language-solidity">modifier onlyAccountant();
</code></pre>
<h3 id="onlyallowed-4"><a class="header" href="#onlyallowed-4">onlyAllowed</a></h3>
<p>Ensures the caller is allowed to perform the action or the gauge is shutdown</p>
<p><strong>Note:</strong>
throws: OnlyAllowed If the caller is not allowed and the gauge is not shutdown</p>
<pre><code class="language-solidity">modifier onlyAllowed(address gauge);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The gauge to check permissions for</td></tr>
</tbody></table>
</div>
<h3 id="constructor-19"><a class="header" href="#constructor-19">constructor</a></h3>
<p>Initializes the strategy with registry, protocol ID, and locker and gateway</p>
<pre><code class="language-solidity">constructor(address _registry, bytes4 _protocolId, address _locker, address _gateway)
    ProtocolContext(_protocolId, _registry, _locker, _gateway);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_registry</code></td><td><code>address</code></td><td>The address of the protocol controller</td></tr>
<tr><td><code>_protocolId</code></td><td><code>bytes4</code></td><td>The identifier for the protocol this strategy interacts with</td></tr>
<tr><td><code>_locker</code></td><td><code>address</code></td><td>The address of the locker contract</td></tr>
<tr><td><code>_gateway</code></td><td><code>address</code></td><td>The address of the gateway contract</td></tr>
</tbody></table>
</div>
<h3 id="deposit-11"><a class="header" href="#deposit-11">deposit</a></h3>
<p>Deposits assets according to the provided allocation</p>
<p><em>Iterates through allocation targets and deposits to each one</em></p>
<p><strong>Notes:</strong></p>
<ul>
<li>
<p>throws: OnlyVault If the caller is not the registered vault for the gauge</p>
</li>
<li>
<p>throws: GaugeShutdown If the pool is shutdown</p>
</li>
</ul>
<pre><code class="language-solidity">function deposit(IAllocator.Allocation calldata allocation, HarvestPolicy policy)
    external
    override
    onlyVault(allocation.gauge)
    returns (PendingRewards memory pendingRewards);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>allocation</code></td><td><code>IAllocator.Allocation</code></td><td>The allocation data specifying where and how much to deposit</td></tr>
<tr><td><code>policy</code></td><td><code>HarvestPolicy</code></td><td>The harvest policy to use</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pendingRewards</code></td><td><code>PendingRewards</code></td><td>Any pending rewards generated during the deposit</td></tr>
</tbody></table>
</div>
<h3 id="withdraw-8"><a class="header" href="#withdraw-8">withdraw</a></h3>
<p>Withdraws assets according to the provided allocation</p>
<p><em>Iterates through allocation targets and withdraws from each one</em></p>
<p><strong>Notes:</strong></p>
<ul>
<li>
<p>throws: OnlyVault If the caller is not the registered vault for the gauge</p>
</li>
<li>
<p>throws: GaugeShutdown If the pool is shutdown</p>
</li>
</ul>
<pre><code class="language-solidity">function withdraw(IAllocator.Allocation calldata allocation, IStrategy.HarvestPolicy policy, address receiver)
    external
    override
    onlyVault(allocation.gauge)
    returns (PendingRewards memory pendingRewards);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>allocation</code></td><td><code>IAllocator.Allocation</code></td><td>The allocation data specifying where and how much to withdraw</td></tr>
<tr><td><code>policy</code></td><td><code>IStrategy.HarvestPolicy</code></td><td>The harvest policy to use</td></tr>
<tr><td><code>receiver</code></td><td><code>address</code></td><td>The address to receive the withdrawn assets</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pendingRewards</code></td><td><code>PendingRewards</code></td><td>Any pending rewards generated during the withdrawal</td></tr>
</tbody></table>
</div>
<h3 id="harvest-4"><a class="header" href="#harvest-4">harvest</a></h3>
<p>Harvests rewards from a gauge</p>
<p><em>Called using delegatecall from the Accountant contract</em></p>
<pre><code class="language-solidity">function harvest(address gauge, bytes memory extraData)
    external
    override
    onlyAccountant
    returns (IStrategy.PendingRewards memory pendingRewards);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The gauge address to harvest from</td></tr>
<tr><td><code>extraData</code></td><td><code>bytes</code></td><td>Additional data needed for harvesting (protocol-specific)</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pendingRewards</code></td><td><code>IStrategy.PendingRewards</code></td><td>The pending rewards after harvesting</td></tr>
</tbody></table>
</div>
<h3 id="flush-1"><a class="header" href="#flush-1">flush</a></h3>
<p>Flushes the reward token to the locker</p>
<p><em>Only allowed to be called by the accountant during harvest operation</em></p>
<pre><code class="language-solidity">function flush() public onlyAccountant;
</code></pre>
<h3 id="shutdown-2"><a class="header" href="#shutdown-2">shutdown</a></h3>
<p>Shuts down the strategy by withdrawing all the assets and sending them to the vault</p>
<p><em>Only allowed to be called by permissioned addresses, or anyone if the gauge/system is shutdown</em></p>
<p><strong>Note:</strong>
throws: OnlyAllowed If the caller is not allowed and the gauge is not shutdown</p>
<pre><code class="language-solidity">function shutdown(address gauge) public onlyAllowed(gauge);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The gauge to shut down</td></tr>
</tbody></table>
</div>
<h3 id="rebalance"><a class="header" href="#rebalance">rebalance</a></h3>
<p>Rebalances the strategy</p>
<pre><code class="language-solidity">function rebalance(address gauge) external;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The gauge to rebalance</td></tr>
</tbody></table>
</div>
<h3 id="balanceof-8"><a class="header" href="#balanceof-8">balanceOf</a></h3>
<p>Returns the balance of the strategy</p>
<pre><code class="language-solidity">function balanceOf(address gauge) public view virtual returns (uint256 balance);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The gauge to get the balance of</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>balance</code></td><td><code>uint256</code></td><td>The balance of the strategy</td></tr>
</tbody></table>
</div>
<h3 id="_getallocationtargets"><a class="header" href="#_getallocationtargets">_getAllocationTargets</a></h3>
<p>Gets allocation targets for a gauge</p>
<pre><code class="language-solidity">function _getAllocationTargets(address gauge) internal view returns (address[] memory targets);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The gauge to get targets for</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>targets</code></td><td><code>address[]</code></td><td>Array of target addresses</td></tr>
</tbody></table>
</div>
<h3 id="_withdrawfromalltargets"><a class="header" href="#_withdrawfromalltargets">_withdrawFromAllTargets</a></h3>
<p>Withdraws assets from all targets</p>
<pre><code class="language-solidity">function _withdrawFromAllTargets(address asset, address gauge, address[] memory targets, address receiver) internal;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>asset</code></td><td><code>address</code></td><td>The asset to withdraw</td></tr>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The gauge to withdraw from</td></tr>
<tr><td><code>targets</code></td><td><code>address[]</code></td><td>Array of target addresses</td></tr>
<tr><td><code>receiver</code></td><td><code>address</code></td><td>Address to receive the withdrawn assets</td></tr>
</tbody></table>
</div>
<h3 id="_harvest-1"><a class="header" href="#_harvest-1">_harvest</a></h3>
<p>Handles the harvest operation</p>
<pre><code class="language-solidity">function _harvest(address gauge, bytes memory extraData, bool deferRewards)
    internal
    returns (IStrategy.PendingRewards memory pendingRewards);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The gauge to harvest from</td></tr>
<tr><td><code>extraData</code></td><td><code>bytes</code></td><td>Additional data needed for harvesting</td></tr>
<tr><td><code>deferRewards</code></td><td><code>bool</code></td><td>Whether to store rewards for later flush (true) or transfer immediately (false)</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pendingRewards</code></td><td><code>IStrategy.PendingRewards</code></td><td>The pending rewards after harvesting</td></tr>
</tbody></table>
</div>
<h3 id="_harvestorcheckpoint"><a class="header" href="#_harvestorcheckpoint">_harvestOrCheckpoint</a></h3>
<p>Harvests or synchronizes rewards</p>
<pre><code class="language-solidity">function _harvestOrCheckpoint(address gauge, IStrategy.HarvestPolicy policy)
    internal
    returns (PendingRewards memory pendingRewards);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The gauge to harvest or synchronize from</td></tr>
<tr><td><code>policy</code></td><td><code>IStrategy.HarvestPolicy</code></td><td>The harvest policy to use</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pendingRewards</code></td><td><code>PendingRewards</code></td><td>The pending rewards after harvesting or synchronization</td></tr>
</tbody></table>
</div>
<h3 id="_getflushamount"><a class="header" href="#_getflushamount">_getFlushAmount</a></h3>
<p>Gets the flush amount from transient storage</p>
<pre><code class="language-solidity">function _getFlushAmount() internal view virtual returns (uint256);
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>uint256</code></td><td>The flush amount</td></tr>
</tbody></table>
</div>
<h3 id="_setflushamount"><a class="header" href="#_setflushamount">_setFlushAmount</a></h3>
<p>Sets the flush amount in transient storage</p>
<pre><code class="language-solidity">function _setFlushAmount(uint256 amount) internal virtual;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>amount</code></td><td><code>uint256</code></td><td>The amount to set</td></tr>
</tbody></table>
</div>
<h3 id="_transfertoaccountant"><a class="header" href="#_transfertoaccountant">_transferToAccountant</a></h3>
<p>Flushes the reward token to the accountant</p>
<p><em>Transfers the specified amount of reward tokens to the accountant</em></p>
<pre><code class="language-solidity">function _transferToAccountant(uint256 amount) internal;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>amount</code></td><td><code>uint256</code></td><td>The amount of reward tokens to flush</td></tr>
</tbody></table>
</div>
<h3 id="_checkpointrewards-1"><a class="header" href="#_checkpointrewards-1">_checkpointRewards</a></h3>
<p>Synchronizes state of pending rewards.</p>
<p><em>Must be implemented by derived strategies to handle protocol-specific reward collection</em></p>
<pre><code class="language-solidity">function _checkpointRewards(address gauge) internal virtual returns (PendingRewards memory);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The gauge to synchronize</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;none&gt;</code></td><td><code>PendingRewards</code></td><td>Pending rewards collected during synchronization</td></tr>
</tbody></table>
</div>
<h3 id="_harvestlocker-1"><a class="header" href="#_harvestlocker-1">_harvestLocker</a></h3>
<p>Harvests rewards from the locker</p>
<p><em>Must be implemented by derived strategies to handle protocol-specific reward collection</em></p>
<pre><code class="language-solidity">function _harvestLocker(address gauge, bytes memory extraData) internal virtual returns (uint256 pendingRewards);
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The gauge to harvest rewards from</td></tr>
<tr><td><code>extraData</code></td><td><code>bytes</code></td><td>Additional data needed for harvesting (protocol-specific)</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pendingRewards</code></td><td><code>uint256</code></td><td>The pending rewards collected during harvesting</td></tr>
</tbody></table>
</div>
<h3 id="_deposit-4"><a class="header" href="#_deposit-4">_deposit</a></h3>
<p>Deposits assets into a specific target</p>
<p><em>Must be implemented by derived strategies to handle protocol-specific deposits</em></p>
<pre><code class="language-solidity">function _deposit(address asset, address gauge, uint256 amount) internal virtual;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>asset</code></td><td><code>address</code></td><td>The asset to deposit</td></tr>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The gauge to deposit into</td></tr>
<tr><td><code>amount</code></td><td><code>uint256</code></td><td>The amount to deposit</td></tr>
</tbody></table>
</div>
<h3 id="_withdraw-4"><a class="header" href="#_withdraw-4">_withdraw</a></h3>
<p>Withdraws assets from a specific target</p>
<p><em>Must be implemented by derived strategies to handle protocol-specific withdrawals</em></p>
<pre><code class="language-solidity">function _withdraw(address asset, address gauge, uint256 amount, address receiver) internal virtual;
</code></pre>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>asset</code></td><td><code>address</code></td><td>The asset to withdraw</td></tr>
<tr><td><code>gauge</code></td><td><code>address</code></td><td>The gauge to withdraw from</td></tr>
<tr><td><code>amount</code></td><td><code>uint256</code></td><td>The amount to withdraw</td></tr>
<tr><td><code>receiver</code></td><td><code>address</code></td><td>The address to receive the withdrawn assets</td></tr>
</tbody></table>
</div>
<h2 id="events-9"><a class="header" href="#events-9">Events</a></h2>
<h3 id="shutdown-3"><a class="header" href="#shutdown-3">Shutdown</a></h3>
<p>Event emitted when the strategy is shutdown</p>
<pre><code class="language-solidity">event Shutdown(address indexed gauge);
</code></pre>
<h3 id="rebalance-1"><a class="header" href="#rebalance-1">Rebalance</a></h3>
<p>Event emitted when the strategy is rebalanced</p>
<pre><code class="language-solidity">event Rebalance(address indexed gauge, address[] targets, uint256[] amounts);
</code></pre>
<h2 id="errors-17"><a class="header" href="#errors-17">Errors</a></h2>
<h3 id="onlyvault-2"><a class="header" href="#onlyvault-2">OnlyVault</a></h3>
<p>Error thrown when the caller is not the vault for the gauge</p>
<pre><code class="language-solidity">error OnlyVault();
</code></pre>
<h3 id="onlyaccountant-2"><a class="header" href="#onlyaccountant-2">OnlyAccountant</a></h3>
<p>Error thrown when the caller is not the accountant for the strategy</p>
<pre><code class="language-solidity">error OnlyAccountant();
</code></pre>
<h3 id="onlyallowed-5"><a class="header" href="#onlyallowed-5">OnlyAllowed</a></h3>
<p>Error thrown when the caller is not allowed to perform the action</p>
<pre><code class="language-solidity">error OnlyAllowed();
</code></pre>
<h3 id="gaugeshutdown-1"><a class="header" href="#gaugeshutdown-1">GaugeShutdown</a></h3>
<p>Error thrown when trying to interact with a shutdown gauge</p>
<pre><code class="language-solidity">error GaugeShutdown();
</code></pre>
<h3 id="depositfailed"><a class="header" href="#depositfailed">DepositFailed</a></h3>
<p>Error thrown when the deposit fails</p>
<pre><code class="language-solidity">error DepositFailed();
</code></pre>
<h3 id="withdrawfailed"><a class="header" href="#withdrawfailed">WithdrawFailed</a></h3>
<p>Error thrown when the withdraw fails</p>
<pre><code class="language-solidity">error WithdrawFailed();
</code></pre>
<h3 id="transferfailed"><a class="header" href="#transferfailed">TransferFailed</a></h3>
<p>Error thrown when the transfer fails</p>
<pre><code class="language-solidity">error TransferFailed();
</code></pre>
<h3 id="approvefailed-1"><a class="header" href="#approvefailed-1">ApproveFailed</a></h3>
<p>Error thrown when the approve fails</p>
<pre><code class="language-solidity">error ApproveFailed();
</code></pre>
<h3 id="rebalancenotneeded"><a class="header" href="#rebalancenotneeded">RebalanceNotNeeded</a></h3>
<p>Error thrown when rebalance is not needed</p>
<pre><code class="language-solidity">error RebalanceNotNeeded();
</code></pre>
<h3 id="alreadyshutdown"><a class="header" href="#alreadyshutdown">AlreadyShutdown</a></h3>
<p>Error thrown when the strategy is already shutdown</p>
<pre><code class="language-solidity">error AlreadyShutdown();
</code></pre>
<h3 id="transfertoaccountantfailed"><a class="header" href="#transfertoaccountantfailed">TransferToAccountantFailed</a></h3>
<p>Error thrown when the transfer to the accountant fails</p>
<pre><code class="language-solidity">error TransferToAccountantFailed();
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="solidity.min.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
