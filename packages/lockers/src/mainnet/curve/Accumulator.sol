// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.19;

import "src/common/interfaces/IVeBoost.sol";
import "src/common/interfaces/IVeBoostDelegation.sol";

import "src/common/accumulator/BaseAccumulator.sol";
import {IStrategy} from "herdaddy/interfaces/stake-dao/IStrategy.sol";
import {ILiquidityGauge} from "src/common/interfaces/ILiquidityGauge.sol";

/// @title A contract that accumulates crvUsd rewards and notifies them to the LGV4
/// @author StakeDAO
contract Accumulator is BaseAccumulator {
    /// @notice Part of Rewards generated by the boosted pools.
    address public constant CRV = 0xD533a949740bb3306d119CC777fa900bA034cd52;

    /// @notice Main revenue token.
    address public constant CRV_USD = 0xf939E0A03FB07F59A73314E73794Be0E57ac1b4E;

    /// @notice Ve CRV.
    address public constant VE_CRV = 0x5f3b5DfEb7B28CDbD7FAba78963EE202a494e2A2;

    /// @notice Ve Boost.
    IVeBoost public veBoost = IVeBoost(0xD37A6aa3d8460Bd2b6536d608103D880695A23CD);

    /// @notice Ve Boost Delegation.
    IVeBoostDelegation public veBoostDelegation = IVeBoostDelegation(0xe1F9C8ebBC80A013cAf0940fdD1A8554d763b9cf);

    uint256 public multiplier;

    ////////////////////////////////////////////////////////////////
    /// --- EVENTS & ERRORS
    ///////////////////////////////////////////////////////////////

    /// @notice Error emitted when a token not supported is used
    error WRONG_TOKEN();

    ////////////////////////////////////////////////////////////
    /// --- CONSTRUCTOR
    ////////////////////////////////////////////////////////////

    constructor(address _gauge, address _locker, address _governance)
        BaseAccumulator(_gauge, CRV_USD, _locker, _governance)
    {
        strategy = 0x69D61428d089C2F35Bf6a472F540D0F82D1EA2cd;
        SafeTransferLib.safeApprove(CRV, _gauge, type(uint256).max);
        SafeTransferLib.safeApprove(CRV_USD, _gauge, type(uint256).max);
    }

    ////////////////////////////////////////////////////////////
    /// --- MUTATIVE FUNCTIONS
    ////////////////////////////////////////////////////////////

    function claimAndNotifyAll(bool notifySDT, bool claimFeeStrategy) external override {
        /// Claim CRVUSD rewards.
        IStrategy(strategy).claimNativeRewards();

        // Claim Extra CRV rewards.
        if (claimFeeStrategy) {
            _claimFeeStrategy();
        }

        notifyReward(CRV_USD, false, false);
        notifyReward(CRV, notifySDT, claimFeeStrategy);
    }

    function _notifyReward(address _tokenReward, uint256 _amount, bool _pullFromFeeReceiver) internal override {
        _chargeFee(_tokenReward, _amount);

        if (_pullFromFeeReceiver && feeReceiver != address(0)) {
            // Split fees for the specified token using the fee receiver contract
            // Function not permissionless, to prevent sending to that accumulator and re-splitting (_chargeFee)
            IFeeReceiver(feeReceiver).split(_tokenReward);
        }

        _amount = ERC20(_tokenReward).balanceOf(address(this));

        if (_tokenReward == CRV) {
            /// Share the BAL rewards with the delegation contract.
            _amount -= _shareWithDelegation();
        }

        if (_amount == 0) return;
        ILiquidityGauge(gauge).deposit_reward_token(_tokenReward, _amount);
    }

    function _shareWithDelegation() internal returns (uint256 delegationShare) {
        uint256 amount = ERC20(CRV).balanceOf(address(this));
        if (amount == 0) return 0;
        if (address(veBoost) == address(0) || address(veBoostDelegation) == address(0)) return 0;

        /// Share the BAL rewards with the delegation contract.
        uint256 boostReceived = veBoost.received_balance(locker);
        if (boostReceived == 0) return 0;

        /// Get the VeBAL balance of the locker.
        uint256 lockerVeBal = ERC20(VE_CRV).balanceOf(locker);

        /// Calculate the percentage of BAL delegated to the VeBoost contract.
        uint256 bpsDelegated = (boostReceived * DENOMINATOR / lockerVeBal);

        /// Calculate the expected delegation share.
        delegationShare = amount * bpsDelegated / DENOMINATOR;

        /// Apply the multiplier.
        if (multiplier != 0) {
            delegationShare = delegationShare * multiplier / DENOMINATOR;
        }

        SafeTransferLib.safeTransfer(CRV, address(veBoostDelegation), delegationShare);
    }

    function setMultiplier(uint256 _multiplier) external onlyGovernance {
        multiplier = _multiplier;
    }

    function setVeBoost(address _veBoost) external onlyGovernance {
        veBoost = IVeBoost(_veBoost);
    }

    function setVeBoostDelegation(address _veBoostDelegation) external onlyGovernance {
        veBoostDelegation = IVeBoostDelegation(_veBoostDelegation);
    }

    function name() external pure override returns (string memory) {
        return "CRV Accumulator";
    }
}
