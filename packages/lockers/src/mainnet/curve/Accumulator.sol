// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.19;

import {IStrategy} from "common/interfaces/stake-dao/IStrategy.sol";
import {ERC20} from "solady/src/tokens/ERC20.sol";
import {SafeTransferLib} from "solady/src/utils/SafeTransferLib.sol";
import {BaseAccumulator} from "src/common/accumulator/BaseAccumulator.sol";
import {ILiquidityGauge} from "src/common/interfaces/ILiquidityGauge.sol";
import {IVeBoost} from "src/common/interfaces/IVeBoost.sol";
import {IVeBoostDelegation} from "src/common/interfaces/IVeBoostDelegation.sol";
import {SafeModule} from "src/common/utils/SafeModule.sol";
import {Curve} from "address-book/src/protocols/1.sol";
import {IFeeDistributor} from "src/common/interfaces/IFeeDistributor.sol";
import {CRV as CurveLockerAddressBook} from "address-book/src/lockers/1.sol";
import {IFeeReceiver} from "common/interfaces/IFeeReceiver.sol";

/// @author CurveAccumulator
/// @notice A contract that accumulates crvUsd rewards and notifies them to the LGV4
/// @author StakeDAO
/// @custom:contact contact@stakedao.org
contract CurveAccumulator is BaseAccumulator, SafeModule {
    ///////////////////////////////////////////////////////////////
    /// --- CONSTANTS
    ///////////////////////////////////////////////////////////////

    /// @notice Part of Rewards generated by the boosted pools.
    address public constant CRV = Curve.CRV;

    /// @notice Main revenue token.
    address public constant CRV_USD = Curve.CRV_USD;

    /// @notice Ve CRV.
    address public constant VE_CRV = Curve.VECRV;

    ///////////////////////////////////////////////////////////////
    /// --- STATE
    ///////////////////////////////////////////////////////////////

    /// @notice Ve Boost V3
    IVeBoost public veBoost = IVeBoost(0xD37A6aa3d8460Bd2b6536d608103D880695A23CD);

    /// @notice Ve Boost Delegation.
    IVeBoostDelegation public veBoostDelegation = IVeBoostDelegation(0xe1F9C8ebBC80A013cAf0940fdD1A8554d763b9cf);

    /// @notice Multiplier applied to the delegation share of CRV rewards sent to veBoost delegators.
    /// @dev Scales the calculated delegation share. Set as a fixed-point value with 1e18 = 100%.
    uint256 public multiplier;

    ////////////////////////////////////////////////////////////////
    /// --- EVENTS & ERRORS
    ///////////////////////////////////////////////////////////////

    /// @notice Error emitted when a token not supported is used
    error WRONG_TOKEN();

    ////////////////////////////////////////////////////////////
    /// --- CONSTRUCTOR
    ////////////////////////////////////////////////////////////

    /// @notice Constructor
    /// @param _gauge Address of the sdCRV-gauge contract
    /// @param _locker Address of the sdCRV locker
    /// @param _governance Address of the governance
    /// @param _gateway Address of the gateway
    /// @dev If `locker` and `gateway` are the same, internal calls will be done directly on the target from the gateway.
    ///      Otherwise, the gateway will pass the execution to the `locker` to call the target contracts.
    /// @custom:throws InvalidGateway if the provided gateway is a zero address
    constructor(address _gauge, address _locker, address _governance, address _gateway)
        BaseAccumulator(_gauge, CRV_USD, _locker, _governance)
        SafeModule(_gateway)
    {
        strategy = CurveLockerAddressBook.STRATEGY;

        // Give full approval to the gauge for the CRV and CRV_USD tokens
        SafeTransferLib.safeApprove(CRV, _gauge, type(uint256).max);
        SafeTransferLib.safeApprove(CRV_USD, _gauge, type(uint256).max);
    }

    //////////////////////////////////////////////////////
    /// --- OVERRIDDEN FUNCTIONS
    //////////////////////////////////////////////////////

    /// @notice Make the locker claim all the reward tokens before depositing them to the Liquidity Gauge (v4)
    function claimAndNotifyAll() external override {
        // 1. Claim locker's claimable CRVUSD rewards
        _execute_claim();

        // 2. Tell the locker to send the CRVUSD rewards to this contract if there are any
        uint256 claimedToken = ERC20(CRV_USD).balanceOf(address(locker));
        if (claimedToken == 0) return;
        _execute_transfer(claimedToken);

        // 3. Tell the Strategy to send the accrued fees to the fee receiver
        _claimFeeStrategy();

        // 4. Notify the rewards to the Liquidity Gauge (V4)
        notifyReward(CRV_USD, false, false);
        notifyReward(CRV, true, true);
    }

    function _notifyReward(address _tokenReward, uint256 _amount, bool _pullFromFeeReceiver) internal override {
        _chargeFee(_tokenReward, _amount);

        if (_pullFromFeeReceiver && feeReceiver != address(0)) {
            // Split fees for the specified token using the fee receiver contract
            // Function not permissionless, to prevent sending to that accumulator and re-splitting (_chargeFee)
            IFeeReceiver(feeReceiver).split(_tokenReward);
        }

        _amount = ERC20(_tokenReward).balanceOf(address(this));

        // Share the rewards with the delegation contract.
        if (_tokenReward == CRV) _amount -= _shareWithDelegation();
        if (_amount == 0) return;

        ILiquidityGauge(gauge).deposit_reward_token(_tokenReward, _amount);
    }

    function _shareWithDelegation() internal returns (uint256 delegationShare) {
        uint256 amount = ERC20(CRV).balanceOf(address(this));
        if (amount == 0) return 0;
        if (address(veBoost) == address(0) || address(veBoostDelegation) == address(0)) return 0;

        /// Share the CRV rewards with the delegation contract.
        uint256 boostReceived = veBoost.received_balance(locker);
        if (boostReceived == 0) return 0;

        /// Get the veCRV balance of the locker.
        uint256 lockerVECRV = ERC20(VE_CRV).balanceOf(locker);

        /// Calculate the percentage of CRV delegated to the VeBoost contract.
        uint256 bpsDelegated = (boostReceived * DENOMINATOR / lockerVECRV);

        /// Calculate the expected delegation share.
        delegationShare = amount * bpsDelegated / DENOMINATOR;

        /// Apply the multiplier.
        if (multiplier != 0) delegationShare = delegationShare * multiplier / DENOMINATOR;

        SafeTransferLib.safeTransfer(CRV, address(veBoostDelegation), delegationShare);
    }

    ////////////////////////////////////////////////////////////////
    /// --- SAFE MODULE RELATED FUNCTIONS
    ///////////////////////////////////////////////////////////////

    function _execute_claim() internal virtual {
        _executeTransaction(
            IStrategy(strategy).feeDistributor(), abi.encodeWithSelector(IFeeDistributor.claim.selector)
        );
    }

    function _execute_transfer(uint256 amount) internal virtual {
        _executeTransaction(CRV_USD, abi.encodeWithSelector(ERC20.transfer.selector, address(this), amount));
    }

    ///////////////////////////////////////////////////////////////
    /// --- SETTERS
    ///////////////////////////////////////////////////////////////

    function setMultiplier(uint256 _multiplier) external onlyGovernance {
        multiplier = _multiplier;
    }

    function setVeBoost(address _veBoost) external onlyGovernance {
        veBoost = IVeBoost(_veBoost);
    }

    function setVeBoostDelegation(address _veBoostDelegation) external onlyGovernance {
        veBoostDelegation = IVeBoostDelegation(_veBoostDelegation);
    }

    ///////////////////////////////////////////////////////////////
    /// --- GETTERS
    ///////////////////////////////////////////////////////////////

    function _getLocker() internal view override returns (address) {
        return locker;
    }

    function version() external pure virtual override returns (string memory) {
        return "4.0.0";
    }

    function name() external view virtual override returns (string memory) {
        return type(CurveAccumulator).name;
    }
}
